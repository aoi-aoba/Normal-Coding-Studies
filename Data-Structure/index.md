# 색인(Index)
자료구조와 알고리즘에서 핵심이 되는 역할은 자신에게 필요한 데이터를 찾는 일이다. 데이터를 잘 찾기
위해서는 저장을 잘 해야 하고, 이때 나중에 데이터를 잘 찾을 수 있게 **색인**&ZeroWidthSpace;을
만드는 것이 중요하다.

색인이 없는 경우를 생각해보면, 어떤 키워드를 가진 사이트를 찾으려고 해도 인터넷의 거대한 연결망 속
어딘가의 사이트를 모두 일일이 들어가서 뒤져야 한다. 어떤 키워드를 포함한 파일을 찾으려고 해도 
색인이 없다면 접근 가능한 모든 파일을 열어 일일이 확인해야만 한다. 대량의 데이터에서의 탐색은
감당할 수 없는 경우이다.

책의 맨 뒷 부분에 '찾아보기'와 같이 핵심 키워드가 들어간 페이지 정보를 알 수 있는 색인(Index)처럼
데이터에도 색인이 있다면 어떤 키워드의 사이트나 파일에 대해 어떤 이름 파일이 어디에 있는지를 색인
검색을 통해 알 수 있게 된다. PC에서 어떤 이름이 더이에 있는지 찾을 수 있게 하는 파일 탐색기의 검색
기능이나 구글과 같은 검색 엔진이 색인 응용의 대표적인 예시이다. 데이터의 저장과 검색은 자료구조와
알고리즘 분야의 가장 중요한 주제 중 하나이고 이 작업을 위한 핵심 인프라가 바로 색인인 것이다.

## 레코드(Record)와 필드(Field)
레코드에는 **개체에 대한 모든 정보**&ZeroWidthSpace;가 들어 있다.
- 사람 레코드 : 주민번호, 이름, 집 주소, 직장 주소, 집 전화번호, 직장 전화번호, 연소득, 최종학력 등
- 동물 레코드 : 종, 속, 과, 목, 강, 문, 계, 육식/초식 구분, 멸종위기종 분류여부, 서식지 등

이들 각각의 정보를 나타내는 부분을 **필드(Field)**&ZeroWidthSpace;라고 한다.

색인은 **개체의 레코드를 검색**&ZeroWidthSpace;하기 위한 것이다. 색인에 레코드를 다 저장하면
이는 데이터베이스가 된다. 색인은 레코드를 대표할 수 있는 필드로 만든다. 다른 레코드와 중복되지 않는
고유값으로 각 레코드를 구분할 수 있는 필드를 색인에 사용하는데, 이를 **키(key) 또는 검색 
키(Search Key)**&ZeroWidthSpace;라 한다. 키는 필드 하나이거나 여러 필드일 수 있다. 색인으로
레코드에 접근하려면 **레코드의 '키'와 '레코드가 저장된 위치'**&ZeroWidthSpace;의 정보가 있으면
된다. 궁극적으로 레코드(또는 파일, 사이트 등)에 빨리 접근하기 위해 검색을 한다는 기술적 문맥을
잊지 말도록 하자.

## 색인과 레코드의 효율성 - 실제 용례를 기준으로
우리나라에서는 국민들에게 주민번호를 부여하므로 각각의 사람들을 이 주민 번호로 구분할 수 있다. 이를
통해 하드 카피로 증빙 자료를 첨부할 일이 거의 없어 이런저런 민원 처리 업무에 대개 30분이 채 걸리지
않는다. 하부에 색인을 포함하는 자료구조 및 레코드가 잘 짜여있기 때문이다. 다만, 이는 사생활 보호의
측면에서는 취약할 수 있다. 그럼에도 최고의 효율성을 보이고 있는 것이다.

일본만 해도 우리나라 행정의 공통으로 보이는 개인 식별 번호 체계가 없기 때문에 의료 관련 작업에서 
국민 5백만 명이 누락되는 사태가 발견되기도 하였다. 미국에는 국민이나 임시 거주민을 구분하는 사회
보장 번호가 있고, 영국에는 국가 보험 번호가 있어 일부 행정에 사용된다. 하지만 이들의 이용은 엄격히
제한되어 국민의 관리가 느슨하다. 이런 시스템으로 선거인 명부도 없고 선거 때는 선거 자격이 있는 
국민이라고 등록하면 된다. 철저한 관리 시스템으로 오용을 방지할 수 있긴 하겠지만 그들은 효율성보다
개인의 프라이버시를 중요히 여긴 것이라고 볼 수 있겠다.

## 색인의 제작
원시적인 방식은 배열에 키를 정렬시킬 수 있겠다. 이러면 색인은 되겠지만 아주 비효율적이다. `n`개의 키
정렬이 된 배열 인덱스는 검색에 평균 $\Theta(\log{n})$이 소요되고, 삽입과 삭제에는 평균적으로
$\Theta(n)$이 들어 시간 복잡도의 문제로 인해 색인의 크기가 충분히 크면 못 쓴다.

이진 검색 트리는 이보다 개선된 저장 방법으로 검색 트리의 기본이 된다. 평균 $\Theta(\log{n})$의
시간이면 검색, 삽입, 삭제가 가능하다. 평균적으로 쓸 만한 성능은 보이나 운이 나쁘면 굉장히 비효율적인
성능이 될 수 있으므로 다양한 구조를 적절히 사용해야 한다.

- 이진 검색 트리
- 다진 검색 트리
- AVL-트리
- 레드-블랙 트리
- B-트리

등등의 다양한 검색 트리를 다뤄보자. 이진 트리인가, 메인 메모리에 있는가, 트리의 균형이 잡혀 있는가에
따라 구분하는 기준으로 생각하면 된다. 여기에서 색인의 사용 위치에 대한 구조를 잠시 생각해보자.

색인을 메인 메모리에 올려놓고 사용하는 경우가 많지만 색인이 어떤 응용 프로그램에게 허용된 메모리
공간에 비해 크다면 디스크에 넣어두고 사용해야 한다. 그래서 메인 메모리에 올려놓고 쓰는 색인은
**내장 색인(Internal Index)** / 메인 메모리의 바깥에 놓고 쓰는 색인은 **외장 색인(External
Index)** 처럼 구분하게 된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/e3ef9406-e106-4a2f-b626-bc440c731c60/image.png)

## 색인의 추상 데이터 타입 (ADT)
```
색인에 키 x를 삽입
색인에서 키 x를 검색
색인에서 키 x를 삭제
색인이 비어 있는지 확인
색인을 비움
```
색인 혹은 찾아보기의 정의를 추상적으로 정리해도 요구하는 작업의 집합이 유일하지는 않다. 필요에 따라
가감할 수 있다. 앞의 3개가 핵심 작업이 된다.
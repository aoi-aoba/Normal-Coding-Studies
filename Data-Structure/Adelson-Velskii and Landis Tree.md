# AVL 트리 (Adelson-Velskii and Landis Tree)
## 균형 검색 트리
이진 검색 트리는 검색과 삽입, 삭제에 평균적으로 $\Theta(\log{n})$ 시간이 소요되지만, 운이 나쁘면 트리의 모양이 균형을 잘 이루지 못해 $\Theta(n)$까지 될 수도 있다. 이런 경우는 드물지만 이런 경우는 사실상 배열로 색인을 만드는 것보다 더 큰 참사가 일어난다. 그래서 고안해낸 것이 바로 균형 이진 검색 트리이다. 최악의 경우에도 이진 트리의 균형이 잘 맞도록 유지하여 작업들이 항상 $O(\log{n})$을 유지하게 하는 방법인데, 대표적으로는 AVL 트리와 레드-블랙 트리가 있다.

## AVL 트리?
이진 검색 트리가 항상 균형을 유지하게 운영하는 대표적인 예시인데,
> 트리 내의 어떤 노드도 좌서브트리와 우서브트리의 높이(깊이) 차가 1보다 크지 않다

라는 조건을 만족하는 상태로 유지되는 이진 검색 트리이다. 어떤 노드이든 간에 이 조건을 만족하게 한다면 AVL 트리가 될 수 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/41ada5e9-c695-49ed-9200-748c84775efa/image.png)


위 사진과 같이 곳곳을 살펴보면 각 노드에서의 우서브트리와 좌서브트리의 높이가 1로서 유지된다. 노드 D에서는 좌서브트리가 1, 우서브트리가 0이다. 노드 F에서는 좌서브트리가 2, 우서브트리가 1이다. 노트 V에서는 좌서브트리가 2, 우서브트리가 1이다. 루트 노드 J에서는 좌서브트리가 3이고 우서브트리가 4이다. 이와 같은 형태로 높이 차가 1보다 크지 않아야 한다.

## 노드 객체의 구조
AVL 트리에서 사용할 노드는 필드로서 `item`, `left`, `right`를 가지는 것은 이진 검색 트리의 노드와도 동일하나, 서브 트리의 높이인 `height`를 추가로 필드로 가진다는 점에 차이가 있다.

## 균형이 깨진 AVL 트리 수선
AVL 트리의 균형이 깨진다면 즉시 수선 과정에 들어간다. AVL 트리의 균형이 깨지는 서브 트리는 무조건 하나라는 보장이 없다. 물론, AVL 트리인 상태에서는 삽입이나 삭제 이후에 균형이 깨질 때 전혀 관계없는 두 곳 이상에서 균형이 깨지는 경우는 발생하지 않는다. 어떤 서브 트리에서 균형이 깨진다면 이를 포함하는 다른 위쪽의 서브 트리도 균형이 깨지는데, 이와 같은 현상이 두 단계 이상에서 발생할 수 있는 것이다.

![](https://velog.velcdn.com/images/aoi-aoba/post/c3ac7224-faa3-4f6c-9eec-163863bc9b79/image.png)

왼쪽의 경우 서브 트리 1개 (트리 10) 균형이 틀어졌다. 이전의 균형이 맞는 트리였다면 아마 10의 왼쪽 자식 노드를 삭제했을 가능성이 높다. 오른쪽의 경우 서브 트리 2개 (트리 10과 트리 40) 균형이 틀어졌다. 이전의 균형이 맞는 트리였다면 키가 35인 노드가 추가되면서 균형이 깨졌을 가능성이 높다. 이처럼 여러 서브 트리에서 균형이 무너졌다면 깨진 서브 트리 중 가장 낮은 위치부터 수선을 시작한다.

왼쪽의 트리를 수선해보자. 수선 기준이 되는 노드(키 10)를 중심으로 한 번 회전하는 것이다. 즉, 서브 트리 10을 회전한 것이다. 그 결과 불균형이 해소되었다. 색칠된 것은 연결 관계에 변화가 생긴 노드를 뜻한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/4b4cbd8b-8f49-4a4a-bc3d-b63d27a01c07/image.png)

### 왼쪽/오른쪽 회전의 로직과 그 알고리즘

왼쪽 회전의 로직은 다음과 같은 알고리즘을 따른다.
```
LeftRotate(t): // 회전의 중심이 되는 노드 t
    RChild <- t.right
    RLChild <- Rchild.left
    RChild.left <- t
    t.right <- RLChild
    RChild.height <- max(RChild.right.height, Rchild.left.height) + 1
    t.height <- max(t.right.height, t.left.height) + 1
```

오른쪽 회전의 로직은 다음과 같은 알고리즘을 따른다.
```
RightRotate(t): // 회전의 중심이 되는 노드 t
    LChild <- t.left
    LRChild <- Lchild.right
    LChild.right <- t
    t.left <- LRChild
    LChild.height <- max(LChild.right.height, Lchild.left.height) + 1
    t.height <- max(t.right.height, t.left.height) + 1
```

### 한 번에 수선되는 AVL 트리?

서브 트리 두 곳에서 문제가 생겼던 두 번째 트리도 수선 가능한지 확인해보자.

![](https://velog.velcdn.com/images/aoi-aoba/post/da2de3e0-d044-4334-aea2-c5c685474b9f/image.png)

서브 트리 10을 왼쪽으로 회전시키니 그 위에 있는 서브 트리 40의 불균형 역시 해소되는 것을 볼 수 있다.

물론, 한 번의 회전으로 불균형이 해소되지 않는 경우도 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/dab8c6f1-3c59-4e52-8e32-2fb31eba442a/image.png)

위와 같은 경우는 단순히 오른쪽으로 한 번 회전시킨 것 뿐이지만 여전히 불균형이 해소되지 않았다. 이 경우를 잘 살펴보면, 트리 37은 부모만 바뀔 뿐 깊이는 유지되었다. 그런 반면 트리 17은 노드 20이 올라가면서 따라 올라가 깊이가 얕아져버린다. 결과적으로 깊이 차가 다시 2로 커지면서 새로 만들어진 트리 20의 균형이 깨지게 된다.

### AVL 트리 수선의 유형 분류

만일 오른쪽으로 회전시키게 되는 경우 회전의 중심이 되는 노드의 왼쪽 자식 노드의 좌서브 트리(LL 서브 트리라고 하자)의 깊이는 한 칸 낮아지고, 우서브 트리(LR 서브 트리라고 하자)의 깊이는 그대로 유지된다. 즉, 아래와 같은 방식으로 해결 가능한 예시도 존재하기 때문에 오른쪽으로 회전하려면 LL 서브 트리가 LR 서브 트리보다 더 얕지 않게 해주는 것이 중요하다. 만일 LR 서브 트리가 더 깊다면 자식 노드를 기준으로 좌회전을 한 번 해서 LL 서브 트리가 더 깊게 만들어주고 오른쪽으로 회전시키는 것이 좋다.

![](https://velog.velcdn.com/images/aoi-aoba/post/34a6089e-02c0-4b8f-8c84-834558c61f50/image.png)

그래서 우선 트리에 불균형이 생겼다면 타입의 파악이 중요하다. 기준 노드의 LL 서브 트리가 더 깊으면 LL 타입, LR 서브 트리가 더 깊으면 LR 타입이라고 한다. LL 타입이라면 단순히 오른쪽으로 회전하면 해결되고, LR 타입이라면 왼쪽으로 회전을 한 번 하고 오른쪽으로 회전한다. 위쪽의 '한 번으로 해결되지 않는 트리' 그림에서 해결되지 않은 이유는 LL 서브트리의 깊이는 2인데 LR 서브트리의 깊이가 3이라서 LR 타입이 되고, 이 경우에서는 단순히 오른쪽으로 회전하면 안 되기 때문이다.

지금과 같은 경우 말고 기준 노드의 우서브 트리가 더 깊은 상태에서 균형이 깨졌다면 RR, RL 타입이 존재한다. RR 타입은 단순히 왼쪽으로 회전하기만 하면 되고, RL 타입은 오른쪽으로 한 번 회전해준 다음에 왼쪽으로 회전해주면 된다. 기준 트리의 좌서브 트리가 더 높은 경우의 작업은 사실상 앞 경우와 좌우가 바뀔 뿐 사실상 동일하다.

아래와 같은 임의의 트리가 주어져도 해결할 수 있게 된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/2e25feca-3040-4431-9343-4d20e199dc4d/image.png)

이 트리의 경우, 기준 노드 40의 좌서브 트리가 더 깊고 LR 서브 트리가 더 깊으므로 LR 타입이다. 그러면 이전에 언급하였듯 먼저 왼쪽으로 회전시킨다. 이때, 트리 40이 아니라 트리 20을 왼쪽으로 회전함에 주의한다. 그러면 일시적으로 불균형이 생기는데, 상관 없다. LL 트리가 되므로 이 상태에서 오른쪽으로 회전시키면 바로잡히며 균형이 맞게 되기 때문이다.

정리하면, `t`를 루트로 하는 트리의 수선 작업은 `t`의 네 손자 서브 트리 중 가장 깊은 것에 따라 다음 네 가지 유형으로 나눌 수 있다.

- LL 타입 : `t.left.left`가 가장 깊은 경우
- LR 타입 : `t.left.right`가 가장 깊은 경우
- RL 타입 : `t.right.left`가 가장 깊은 경우
- RR 타입 : `t.right.right`가 가장 깊은 경우

## AVL 트리 수선의 유형별 해결방법
### LL 타입의 해결 방법
LL 타입은 루트 `t`를 기준으로 오른쪽으로 회전한다. 내용에 변화가 생기는 것은 파란색으로 변경하였는데, 두 개의 링크와 두 개의 노드에 대해서 변화가 생김을 알 수 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/3de132ad-427e-4ec8-ae6b-54c912d1d985/image.png)

### LR 타입의 해결 방법
LR 타입은 `t.left`를 기준으로 왼쪽으로 회전시켜 LL 타입으로 만든 다음 `t`를 기준으로 오른쪽으로 회전하면 된다. 편의상 모든 깊이가 같은 형태로 그렸는데, 모든 LR 타입이 이런 방식으로 정렬되지는 않는다.

![](https://velog.velcdn.com/images/aoi-aoba/post/7a5f2f10-df5a-4f2c-b451-b3b424de4bbc/image.png)

### RR 타입의 해결 방법
`t`를 기준으로 왼쪽으로 회전시킨다. LL 타입과 정확히 좌우 대칭으로 동일한 원리가 작용한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/036080f8-77aa-4add-a8a3-7e8a67758827/image.png)


### RL 타입의 해결 방법
`t.right`를 기준으로 오른쪽으로 회전시켜 RR 타입으로 만든 다음 `t`를 기준으로 왼쪽으로 회전하면 된다. LR 타입과 정확히 좌우 대칭으로 동일한 원리가 적용된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/a0609930-c893-407f-99c6-55c34fb0c926/image.png)

## 통합 알고리즘
위에서 설명한 네 가지 유형의 수선 작업을 정리하면 다음과 같은 알고리즘이 된다.
```
balanceAVL(t, type):
    switch type:
        case LL: RightRotate(t)
        case LR: LeftRotate(t.left)
                 balanceAVL(t, LL)
        case RR: LeftRotate(t)
        case RL: RightRotate(t.right)
                 balanceAVL(t, RR)
```

주의해야 할 점이 있다면, `balanceAVL`은 노드 `t`를 루트로 하는 서브 트리에 관해서만 수선을 보장하기 때문에 서브 트리의 단계가 굉장히 세분화되어있는 큰 트리라면 그 상위 트리에 대한 수선은 별개로 진행해야 한다. 즉, 추가적인 수선은 재귀적으로 루트까지 되돌아 올라가면서 거쳐가는 노드들에 대해 모두 `balanceAVL`을 실행해줘야만이 수선 작업이 제대로 전체적으로 일어나는 것이다.

## 알고리즘 일반화 - 노드 NIL을 사용하기
Java로 AVL 트리를 구현할 때 유용한 알고리즘 일반화 기술이 있다. 바로, 레퍼런스가 `null`인 경우에 대해 자바의 상수 `null`을 사용하지 않고 AVLNode 타입의 노드 NIL을 사용하는 것이다. 모든 `null` 레퍼런스가 이 노드를 가리키게 하는데, 이 이유는 서브 트리의 높이 계산을 위한 필드 `height`을 처리하기 쉽게 하기 위해서이다.

일반적인 `null`을 사용하게 된다면 어떤 노드 `x`의 높이 참조를 위해 `x.height`를 사용할 수 없다. 왜냐하면, `x`가 `null`이라면 `x.height`는 존재하지 않는 필드가 되기 때무이다. 이런 경우를 해결하려면 일일이 `x`의 `null` 여부를 확인하여 처리하거나 따로 메서드를 활용하여 처리해주어야한다.

그래서 `NIL`을 사용함에 따라 노드 `x`가 `null`이라도 `NIL.height`는 존재한다. 즉, 다른 노드와 같이 높이 관련 작업을 동일하게 처리 가능하게 할 수 있다. 그러므로 `NIL`의 필드 `NIL.height`는 0으로 값을 초기화해두면 된다. 이런 방식으로 사용하는 노드를 경걔 노드(sentinel)이라고 한다. 

## 구현
JAVA를 활용해 구현한 코드는 Normal-Coding-Studies/Data-Structure-With-JAVA/Data-Structure/out/production/Data-Structure/BST 내에 있다.
# 버킷 정렬(Bucket Sort) 알고리즘

## 버킷 정렬이란?
버킷 정렬은 정렬하고자 하는 원소들이 **균등 분포(Uniform Distribution)** 상태를 이룰 때를 가정한
유용한 정렬 알고리즘이다. 정규 분포가 가운데에 가장 많이 몰리고 가장자리로 가면서 수가 적어지는 종형
분포인데 반해, 균등 분포는 데이터가 **전 영역에 걸쳐 고르게 존재하는** 분포이다. 전체적으로 보았을
때 어느 지점에서나 데이터가 존재할 **"확률이 같다"**&ZeroWidthSpace;는 것이다.

![](https://velog.velcdn.com/images/aoi-aoba/post/089eddee-eac2-403a-9068-b515a9a58d1a/image.png)

위 데이터셋 시각화 상황을 보면 균등 분포하는 데이터들의 출현 빈도가 일정 기대 출현 횟수를 기준으로 
하여 들쭉날쭉한 상태임을 볼 수 있다. 컴퓨터에서 랜덤으로 생성한 데이터는 기댓값보다 못 미치거나
기댓값 이상인 경우도 나타나지만 **전반적으로는 균등 분포를 따르는** 형태에 가까워진다.

## 버킷 정렬의 아이디어
15개의 원소로 이루어진 배열에 대한 버킷 정렬 알고리즘 수행 예시를 사진을 통해 확인해보자. 데이터는
`A[0...14]`에 담겨 있으며 `[0,1]` 사이의 값들로 주어져 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/e98ba0dd-ce60-41aa-aab1-a1d652cd33dd/image.png)

정렬할 원소들이 주어지면, 배열 원소 각각에 대해 배열 사이즈인 15를 곱해서 **소숫점 이하를 버리고
정수부만 취한다.** 이 값이 각 원소가 **위치하게 될 버킷의 번호** 할당을 좌우한다. 계산된 번호의
리스트에 원소 각각을 삽입한다. (버킷 리스트 위치 부분과 버킷 리스트 삽입이 별도로 그려져 있지만,
버킷 리스트 위치를 확인하기 위해 별도의 배열을 만드는 것은 아니다.) 각 리스트의 원소들을 그룹별로
정렬하고, 원소들을 차례대로 배열 A로 다시 옮겨주면 된다.

여기서는 `[0, 1]` 사이의 실숫값으로 가정했지만 반드시 그럴 필요는 없고 단순히 `[a, b]` 사이의 실수
범위라면 균등 분포이기만 한다면 모두 `[0, 1]` 사이의 실숫값으로 매핑할 수 있다. 알고리즘에서의
간명함을 위해 이렇게 변환된 데이터를 가정한다.

## 버킷 정렬의 알고리즘
먼저, n개의 **리스트 배열** 준비가 필요하다. 각각에는 평균 1개 원소가 들어오는데 확률 편차에 의해
없을 수도 있고 여러 개가 있을 수도 있다. 해당 영역을 `n`개의 동일한 윈도우 크기로 자르면, 그 각각에
들어 있는 **원소들이 한 버킷(리스트)에 저장된다.** 총 `n`개의 원소, `n`개의 버킷이므로 기댓값은
1이다. 이들을 간단히 정렬해주면 된다. 그리고 정렬된 원소를 버킷 순서대로 내려받으면 정렬이 끝난다.

```
bucketSort(A[], n):
    for i <- 0 to n-1
        A[i]를 리스트 B[nA[i]]에 삽입한다 // B는 각각이 리스트인 배열
    for i <- 0 to n-1
        리스트 B[i]에 있는 원소들을 정렬한다 // 삽입 정렬이면 충분
    B[0], B[1], ..., B[n-1]의 원소들을 차례대로 A[0...n-1]로 복사한다
```

## 버킷 정렬의 수행시간 판단
위는 기본형 버킷 정렬이다. 균등 분포를 이루는 입력에 대해 이론적으로는 $\Theta(n)$의 선형 시간이
소요되지만, 실제로 구현하면 $\Theta(n)$의 **상수 인자가 매우 크다.** 사실상 $\Theta(n\log{n})$
보다 실속이 없다. 심지어 리스트 할당을 위해 **메모리를 동적 할당하는데,** 그 부담이 크다. 배열이 
크면 관련된 공간 소모가 심각한데, 정수 데이터 1억 개로 버킷 정렬을 한다면 정렬의 수행 과정에 쓸 수 
있는 공간이 7.2GB 정도라고 해도 메모리가 감당할 수 없다. 버킷 내에서의 연결 리스트 제작 간에 공간 
부족에 걸리는 것이다. 그래서 연결 리스트를 만들거나 물리적인 버킷 유지 없이도 구현 가능한 
아이디어가 있다.

## 버킷 정렬의 추가적인 개선 아이디어
버킷 리스트를 사용하지 않고도 버킷 정렬의 구현이 가능하다. **각 버킷의 원소 수를 세는 것**&ZeroWidthSpace;
에서 비롯한다. 각 버킷의 원소들의 수를 세는 것은 간단하기 때문에 이를 기반으로 원소들이 들어갈 배열
`A[]`의 범위를 알 수 있다. 계수 정렬의 아이디어를 차용한 것인데, 계수 정렬이 특정 원소들의 개수를
센다고 한다면 버킷 정렬에서는 **특정 범위의 수를 센다.** (전체 구간을 n개로 나누어 각 구간에 들어갈
원소의 개수를 세면 된다.) 이를 기반으로 버킷 대신에 `A[0...n-1]`에 바로 집어넣어 후속 처리하면 된다.

## 구현
JAVA를 활용해 구현한 코드는
Normal-Coding-Studies/Data-Structure-With-JAVA/Data-Structure/src/Data-Structure/sort
내에 있다.
# 너비 우선 탐색 (Breadth-First Search, BFS)
## 개요
그래프에서 모든 정점을 방문해야만 하는 경우가 자주 있다. 모든 정점을 방문하는 대표적인 방법 두 가지는 너비 우선 탐색과 깊이 우선 탐색 알고리즘이다. 두 방법은 매우 간단하지만 그래프 알고리즘에서 핵심적인 위치를 차지한다.

너비 우선 탐색의 경우는 루트부터 시작했다면 루트의 자식을 차례로 방문한다. 다음으로 루트 자식의 자식, 즉 루트에서 두 개의 간선을 거쳐서 도달할 수 있는 정점을 방문한다. 그 다음으로 3개의 간선, 4개의 간선, ... 과 같은 과정을 거쳐서 도달할 수 있는 정점을 순을 방문한다.

이와 반대로 깊이 우선 탐색은 루트의 자식 정점을 하나 방문한 다음 아래로 내려갈 수 있는 곳까지 내려간다. 더 이상 내려갈 수 없다면 위로 되돌아오다가 내려갈 곳이 있다면 즉각 내려간다. 아래는 트리를 대상으로 한 너비 우선 탐색과 깊이 우선 탐색의 예시이며, DFS에 기반한 탐색 방법을 백트래킹(Backtracking)이라고 총칭하기도 한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/184f5eae-4373-4dd8-8b06-1bf4cb080420/image.png)


## 무방향 그래프에 대한 BFS의 수행 예시
무방향 그래프에 대하여 BFS를 수행하는 예시를 통해 알고리즘을 차례로 살펴보자. 

![](https://velog.velcdn.com/images/aoi-aoba/post/2346ffcd-23f4-4f0c-a5d9-e4853c83c969/image.png)

(a) 시작 정점으로 정해진 정점을 1로 표시하며 방문한다.   
(b) 정점 1에 인접한 모든 정점을 방문하여 각각 2, 3, 4로 표시한다.   
(c) 정점 2에 인접한 모든 정점 중에 방문하지 않은 정점은 없다.   
(d) 정점 3에 인접한 모든 정점을 방문한다. 하나밖에 없어 5로 표시한다.   
(e) 정점 4에 인접한 모든 정점을 방문한다. 각각 6, 7로 표시한다.   
(f) 정점 5에 인접한 모든 정점 중에 방문하지 않은 정점은 없다.   
(g) 정점 6에 인접한 모든 정점을 방문한다. 하나밖에 없어 8로 표시한다.   
(h) 정점 7에 인접한 모든 정점 중에 방문하지 않은 정점은 없다.   
(g) 정점 8에 인접한 모든 정점 중에 방문하지 않은 정점은 없고 더 이상 갈 곳이 없다. 종료.

각 정점을 처음 방문할 때 사용하는 간선은 하나이므로 시작점을 제외한 나머지 $n-1$개의 정점 각각에 대해 첫 방문에 사용한 간선을 모으면 $n-1$개가 된다. 그래프에서 이 간선들만 남긴 상태로 두면 아래와 같은 트리가 되는데, 이를 BFS 트리(너비 우선 트리)라고 한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/e7cdca77-6019-4684-a4ab-dfd426034ac6/image.png)

## BFS 알고리즘의 작동 방식
```
BFS(G, s)
    // G는 그래프 G=(V, E), s는 시작 정점
    for each v in set V-{s}
        v.visited <- NO
    s.visited <- YES
    enqueue(Q, s)
    // Q는 큐 자료구조
    while (Q != null set)
        u <- dequeue(Q)
        for each v in set u.adj
        // u.adj는 정점 u에 인접한 정점들의 집합
            if (v.visited = NO)
                v.visited <- YES
                enqueue(Q, v)
```

이 알고리즘에서는 큐 자료구조를 활용하는데, 우선 시작 정점을 제외한 모든 정점을 "방문하지 않음"으로 표시한다. 큐의 맨 앞에 있는 정점을 빼내고 이에 인접한 정점 중에서 방문하지 않은 정점을 모두 "방문하였다"로 표시하면서 큐에 넣는다. 이 작업을 계속 반복한다. `BFS()`가 반복 수행되는 동안 정점 `s`에서 도달 가능한 모든 정점은 `enqueue()`와 `dequeue()`를 통해 각각 한 번씩 큐에 들어갔다 나온다.

BFS는 시작 정점으로부터 방문할 수 있는 모든 정점을 방문하는 것을 목표로 하거나 모든 정점을 목표로 할 수도 있다. 경우에 따라서는 `BFS()`를 여러 번 수행해야 할 수도 있다. 이 알고리즘은 항상 그래프 `G`의 모든 정점을 방문하는 것이 아니라 시작 정점 `s`로부터 간선을 타고 방문할 수 있는 모든 정점을 방문하기 때문이다. 만약 여러 개로 그래프가 끊겨 있다면 아직 방문되지 않은 정점 중 하나를 골라 새 `BFS()`를 실행해야 한다. 여러 개로 끊긴다면 덩어리 개수만큼 `BFS()`를 실행한다.

수행 시간은 $\Theta(V+E)$이다. 여러 번 수행해야 할 경우까지 고려하여 모두 합한 시간이며, 정점의 수 $|V|$와 간선의 수 $|E|$ 대신 혼동의 염려 없이 표기한 것이다.
# 퀵 정렬(Quick Sort) 알고리즘

## 퀵 정렬의 아이디어
병합 정렬은 재귀적으로 작은 문제를 해결한 다음에 후처리를 하지만, 퀵 정렬은 **선행 작업을 한 다음 재귀적으로 작은
문제를 해결**&ZeroWidthSpace;하는 방식이다. 기준 원소에 대해 **작은 원소와 큰 원소 그룹으로** 나눠 분할하여 
정렬한다. 평균적으로 좋은 성능을 보이기 때문에 현장에서 잘 쓰인다.

아래 그림을 보자. 퀵 정렬을 간단한 예시로 나타낸 것이다. 그 어떤 원소도 기준점이 될 수 있는데, 기준 원소로 예시를 위해
맨 뒤 원소 15를 기준 원소로 삼아보자. 그런 다음, 이를 중심으로 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 재배치해준다.
왼쪽의 원소와 오른쪽의 원소를 이후 각각 독립적으로 정렬하면 되는데, 15의 자리는 영향을 받지 않는다. 그러니 기준 원소는
사실상 정렬을 시작하기도 전에 이미 제자리를 찾은 것이다. 왼쪽과 오른쪽이 종료되는 순간 전체 정렬은 종료된다. 자명한
이야기지만, 왼쪽과 오른쪽에는 퀵 정렬을 재귀적으로 사용하면 된다. 기준 원소와 같은 원소는 왼쪽과 오른쪽 어디에 두어도
되는데, 로직 내에서의 **부등호 방향** 영향을 받게 된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/3e117db3-8820-44a5-a721-9dea8c1cc0db/image.png)

## 퀵 정렬의 주요 알고리즘
```
quickSort(A[], p, r):
    if (p < r)
        q <- partition(A, p, r)     // 기준 원소에 따른 분할
        quickSort(A, p, q-1)        // 기준 원소 왼쪽의 정렬
        quickSort(A, q+1, r)        // 기준 원소 오른쪽의 정렬
        
partition(A[], p, r):
    배열 A[p...r]의 원소를 기준 원소 A[r]의 상대적 크기에 따라 양쪽으로 재배치하고 기준 원소가 자리한 위치를 리턴
```
기준 원소를 중심으로 왼쪽/오른쪽으로 나누고 2개의 퀵 정렬을 재귀적으로 호출한다.   
기준 원소를 중심으로 나누는 방법은 여러 가지가 있는데, 어떤 방법을 쓰더라도 크게 문제가 없다.    
대표적으로 사용되는 분할 방법을 알아보자.

## 퀵 정렬의 분할 알고리즘
```
partition(A[], p, r):
    x <- A[r]              // 기준 원소
    i <- p-1                // i는 1구역의 끝 지점
    for j <- p to r-1    // j는 3구역의 시작 지점
        if (A[j] < x)
            A[++i] <-> A[j]     // i값 증가 이후 swap
    A[i+1] <-> A[r]       // 기준 원소와 2구역의 첫 원소를 교환
    return i+1
```
분할 알고리즘의 작동 원리를 그림과 함께 예시를 통해 알아보자. 분할 알고리즘에서 배열을 네 가지 구역으로 나눌 것이다.

- 1구역 : 기준 원소보다 작은 원소들 (빨간색 음영으로 표시됨)
- 2구역 : 기준 원소보다 크거나 같은 원소들 (보라색 음영으로 표시됨)
- 3구역 : 아직 판단하지 않은 원소들 (음영이 없음)
- 4구역 : 기준 원소 자신 (초록색 음영으로 표시됨)

3구역의 원소를 하나씩 차례대로 보면서 1구역이나 2구역에 포함시킨다. 이때, `i`라는 변수는 **1구역의 끝을 지칭하는** 변수로,
여기서는 처음에 -1의 값을 가진다. 그리고 `j`라는 변수는 **3구역의 시작 부분을 지칭하는** 변수이다. 즉, 아직 보지 않은
원소 중 가장 앞에 있는 원소를 가리키게 된다. 2구역은 1구역과 3구역의 사이이므로 따로 지칭할 필요는 없다.

각각의 for 루프에서는 3구역의 첫 원소 `A[j]`를 기준 원소와 비교한다.   

(1) 만약 `A[j]`가 기준 원소보다 크다면   
2구역이 한 칸 더 증가해야 한다. 그러면 사실상 해줄 것은 없다. `j`는 어차피 for 루프로 인해 커지기 때문이다.

(2) 만약 `A[j]`가 기준 원소보다 작다면   
1구역이 한 칸 더 증가해야 한다. 그렇기 때문에 우선 **1구역을 한 칸 넓히기 위해** `++i`를 먼저 해준다.   
그러면 i는 2구역의 맨 첫 원소의 위치에 닿게 될 것인데, 이 원소와 3구역의 첫 원소를 swap한다. 그러면 **1구역의 마지막에 
원소가 제대로 위치하게 될** 것이고, 동시에 3구역의 맨 처음에 2구역의 맨 첫 원소가 위치하게 되는데, 이는 **for 루프로 
인해 자동으로 `j`가 확장되면서** 해결 될 문제이므로 크게 관여할 필요가 없다.

3구역을 모두 소진하고 나면, 2구역의 첫 번째 원소와 해당 원소를 변경해주면 된다. 그렇게 되면 안 본 원소는 없다. 그렇기 때문에
리턴 값은 **4구역인 기준 원소가 위치한 장소가** 된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/daf176e1-0b17-4a42-9462-6d5a66755493/image.png)

## 퀵 정렬의 수행시간 판단
퀵 정렬은 평균적으로 $\Theta(n\log{n})$의 시간 복잡도를 가지게 된다.   
최악의 경우는 한 쪽이 아예 없고 다른 쪽에 다 몰리게 분할되는 일이 계속 반복되는 경우로, $\Theta(n^2)$이 걸린다.   

한 쪽이 텅 비지 않아도 분할이 대부분 극심하게 맞지 않으면 시간이 $\Theta(n^2)$으로 치닫는데, 한쪽이 완전히 비거나
이에 근접한 상태가 지속된다면 비효율적인 시간이 나올 수 있다는 것이다. 이런 불운한 경우가 반복될 확률이 낮아도 없다는 것은
아니기 때문에 가끔 발생하는 이 경우를 생각해볼 필요가 있다.

## 퀵 정렬의 불운한 경우(worst-case)가 반복되는 조건
퀵 소트의 핵심은 **피벗(pivot)** 즉 기준 원소를 중심으로 두 하위 배열(sub-array)로 나누는 과정이다. 이때, 분할이 항상
극단적으로 한쪽으로 치우치는 경우, 예컨데 한쪽은 `n-1`개, 다른 한쪽은 0개와 같은 분할이 반복되면 재귀 호출의 깊이가 `n`에
가까워지고 시간 복잡도가 $O(n^2)$에 가까워지게 되는 것이다.

대부분의 불운한 입력 조건은 다음과 같다.
- 피벗 선택을 항상 첫 원소나 마지막 원소처럼 고정된 방식으로 진행하는 경우
- 입력 배열이 이미 정렬되어 있거나 거의 정렬된 상태인 경우 (역순도 포함)

> [ 1, 2, 3, 4, 5, 6, 7, 8, 9]
> 
> 코딩테스트의 테스트 케이스에서 다음과 같은 배열을 주었다고 생각해보자. 테스트케이스는 어떤 방식으로 줄 지 모르기 때문에
> 일단 배열을 정렬하기 위해 들어가게 된다면, 맨 앞 원소나 맨 뒤 원소를 고르면 최악의 경우에 치닫는다. 맨 앞 원소의 경우
> 항상 pivot 뒤에 n-1개의 오른쪽 배열이 주어지고, 맨 뒤 원소의 경우 항상 pivot 앞에 n-1개의 왼쪽 배열이 주어지게 된다.

즉, 재귀 깊이 `n`과 함께 시간이 $O(n^2)$이 발생하며 반복적으로 당하게 되는 것이 불운한 분할이 반복되는 경우에 해당한다.

또, 퀵 정렬의 성능이 좋지 않은 경우가 있는데 동일한 원소가 많이 존재하는 것이다. 입력의 모든 원소가 동일한 극단적인 경우
이미 정렬된 것처럼 분할 성능과 균형이 항상 최악에 치닫게 되기 때문이다. 퀵 정렬의 경우 같은 원소는 덩어리로 모이는데
알고리즘은 이 사실을 알지 못한 채 분할을 시도한다.

## 퀵소트의 평균 수행 시간 분석
평균 수행 시간 분석이란, **가능한 모든 입력 순열**&ZeroWidthSpace;에 대하여 소트가 수행하는 **비교 횟수의 기댓값을**
구하는 것이다. 퀵소트에서의 재귀식 구조는 다음과 같다.

$$T(n) = T(k) + T(n-k-1) + cn$$

여기에서 $k$는 피벗보다 작은 원소의 개수, $n-k-1$은 피벗보다 큰 원소의 개수이며, $cn$은 분할 과정에서 수행되는 비교
횟수이다. 피벗과 나머지 $n-1$개의 원소에 대한 비교에서 발생하게 되는 것이다. 이제 기댓값 $E(n)$을 설정해보자. 크기 $n$개
배열에 대해 평균적으로 필요한 비교 횟수를 생각해보기 위해, 전체 입력 배열의 가능한 순열을 생각해보면 $n!$개이다. 각 순열에
대해 퀵소트가 수행하는 비교 횟수를 합쳐 기댓값을 산출할 수 있다.

입력 배열에서 임의의 원소가 피벗으로 선택될 확률은 $\frac{1}{n}$으로 동일하므로, 피벗이 `i`번째 원소일 확률도 동일하다.
이때의 평균 비교 횟수는 다음과 같다.

$$E(n) = \frac{1}{n}\sum_{k=1}^{n-1}{E(i) + E(n-i-1)+(n-1)}$$

$E(i)$와 $E(n-i-1)$은 좌우의 하위 배열에 대해 재귀적으로 호출된 퀵소트의 평균 비교 횟수를 의미한다. $(n-1)$은 현재의 분할
과정에서 피벗과 비교되는 횟수를 의미한다. 위 점화식을 해결하게 된다면, 다음과 같은 결과를 얻을 수 있다.

$$E(n) \approx 2n\ln{n} \approx 1.386n\log_2{n}$$

즉, 퀵소트는 평균적으로 약 $1.386n\log_2{n}$번 비교를 수행하게 된다. (병합 정렬의 평균 비교 횟수보다 적음, 계수 차이)
이때, 피벗이 항상 k:1의 비율로 분할될 때의 시간은 다음과 같은 재귀 관계로 표현된다.

$$T(n) = T(kn) + T((1-k)n) + cn$$

예를 들어, $k=0.9$ (즉, 한쪽이 90%, 한쪽이 10%)의 비율만 계속 나와도 성능이 저하된다. 여기에서 분할 비율이 고정되어 있음에
따라 재귀 깊이는 log base(1/k) 정도가 된다. 상수항을 무시하고 근사화한다면 $T(n)=O(n\log{n})$으로 나타나긴 하나, $k$가
0에 수렴해나갈 때 분할 편향이 심해지면서 $\Theta(n^2)$으로 가까워지며 시간 복잡도가 최악에 치닫게 되는 것이다.

![](https://velog.velcdn.com/images/aoi-aoba/post/fbb2754c-06ad-4b28-b4d7-d356fdd63851/image.png)

```python
import matplotlib.pyplot as plt
import numpy as np

def quicksort_time(n, k, c=1):
    # Base case: small enough n
    if n <= 1:
        return 0
    # Divide sizes
    left = int(k * n)
    right = n - 1 - left  # exclude pivot
    return quicksort_time(left, k, c) + quicksort_time(right, k, c) + c * n

n_values = np.arange(10, 500, 10)
ratios = [0.5, 0.25, 0.1, 0.01]
results = {}

for k in ratios:
    times = [quicksort_time(n, k) for n in n_values]
    results[f"k={k}"] = times

# Plot
plt.figure(figsize=(10, 6))
for label, times in results.items():
    plt.plot(n_values, times, label=label)

plt.title("QuickSort Time for Input Size (for various fixed k:1 split ratios)")
plt.xlabel("Input Size (n)")
plt.ylabel("Estimated Time T(n)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
```

그래프를 보면 알 수 있지만, $k=0.5$의 가장 이상적인 균형 분할일 때 가장 완만하게 증가하고, $k=0.1$정도에서 급격한
비효율을 보여주기 시작하는데, 이 경우가 $k=0.01$에 치닫게 된다면 유사하게 $O(n^2)$에 수렴하면서 최악에 달한다.

k=0이 된다면 굳이 말할 필요도 없을 텐데, 이 경우가 같은 원소들이 덩어리로 모였을 때의 경우이다. 덩어리의 크기가 $k$라면
분할은 $0:k-1$로 분할되기 때문에 부분 정렬이 $O(k^2)$의 시간이 소요된다. 이 문제는 물론 간단히 해결 가능한데, 기존
원소와 동일한 원소를 만나면 양쪽에 골고루 나눠주도록 변경하면 된다.

## 수학적 귀납법을 활용한 퀵소트의 합리성 증명
```
quickSort(A[], p, r):
    if (p < r)
        q <- partition(A, p, r)
        quickSort(A, p, q-1)
        quickSort(A, q+1, r)
```
위 알고리즘을 기반으로 하여 정렬하고자 하는 원소의 총 수는 $n = r-p+1$이다.   
$n=1$이거나 $n=0$이라면 첫 번째 if문에서의 비교 이후 아무 일도 하지 않고 바로 알고리즘을 마친다. 원소가 하나인 상태거나
원소가 없는 경우이므로 논리적으로 제대로 정렬한다고 말할 수 있다. 이때, 크기가 $n$보다 작은 모든 문제에 대해 퀵소트가 
제대로 정렬된다고 가정하자. 문제 크기가 $n$일 때, 퀵 정렬이 호출된다면 왼쪽/오른쪽의 부분 배열을 정렬하는 과정을 호출하는데
이들은 모두 크기가 $n$보다 작기 때문에 귀납적 가정에 의해 제대로 정렬된다. 이들은 분할 과정(`partition()`)에 의하여 
중심 pivot 기준으로 작은 것은 왼쪽, 크거나 같은 것은 오른쪽에 배치하였기 때문에 p에서 q-1까지 정렬된 모든 원소들은
q+1에서 r까지 정렬된 모든 원소들보다 작다. 이 결과로 인해 정렬된 왼쪽 원소들 < 기준 원소 <= 정렬된 오른쪽 원소들 형태가
됨에 따라 제대로 정렬된 상태가 된다.   
그러므로 퀵 정렬은 0 이상의 모든 $n$에 대하여 제대로 정렬된다는 것이 증명되었다.

## 구현
JAVA를 활용해 구현한 코드는 Normal-Coding-Studies/Data-Structure-With-JAVA/Data-Structure/src/Data-Structure/sort 내에 있다.
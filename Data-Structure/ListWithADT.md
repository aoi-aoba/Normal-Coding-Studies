# 리스트(List)
## 리스트 구조와 작업
리스트는 **줄 세워진 데이터** 혹은 **나열된 데이터**를 의미한다.   
리스트에 사용하기 위해 필요한 작업을 ADT(추상 데이터 타입)로 나타내면 다음과 같다.
```
i번째 자리에 원소 x를 삽입한다.
i번째 원소를 삭제한다.
원소 x를 삭제한다.
i번째 원소를 알려준다.
원소 x가 몇 번째 원소인지 알려준다.
리스트의 사이즈(원소의 총 개수)를 알려준다.
```
- 파이썬(Python)의 경우는 **리스트가 기본 자료구조**&ZeroWidthSpace;이므로 많은 작업을 지원한다.
- 자바(JAVA)의 경우는 기본 자료구조가 아니고 java.util 패키지에서 제공한다.

## 배열을 활용한 리스트의 구현
배열을 이용한 리스트는 시작 위치부터 빈 자리가 없는 상태로 순서대로 연속하여 자료를 저장한다.   
**논리적 순서와 물리적 순서**&ZeroWidthSpace;가 일치하고 원소의 삽입과 삭제에도 빈자리 없이 자료가 저장된다.   
반면 연결 리스트의 경우는 **순서와 무관하게 링크에 의해** 논리적 순서를 표현한다.   
즉, 삽입과 삭제 연산을 하더라도 **링크 정보만 변경하고** 물리적 순서는 변경되지 않는다.   
배열로 리스트를 구현하면 가장 단순히 구현이 가능하지만 리스트에 원소가 얼마나 들어올지 알 수 없으므로 공간 확보가 필요하다.   
공간 확보 간에 낭비가 없으려면 **빠듯한 배열 크기** 확보로 인해 공간이 다 차면 다른 배열을 할당받아 다시 원소를 옮겨야 한다.   
그럼에도 불구하고 배열 방식이 단순하고 효율성이 높기 때문에 구현이 편한다.

## 배열의 객체 구조
배열 리스트가 하나의 객체(Class)로서 정의된다고 했을 때, 구조는 다음과 같다:
- **필드** : 배열 `item[]`(원소가 저장되는 배열), 변수 `numItems`(원소의 총 수를 저장)
- **메소드** : `add(), append(), remove(), removeItem(), get(), set(), indexOf(), len(), isEmpty(), clear()`
    - `add(i, x)` : 리스트의 i번째 원소로서 x를 삽입한다. (맨 앞자리는 0번째)
    - `append(x)` : 리스트의 맨 뒤에 원소 x를 추가한다.
    - `remove(i)` : 리스트의 i번째 원소를 삭제한다.
    - `removeItem(x)` : 리스트에서 처음으로 나타나는 원소 x를 삭제한다.
    - `get(i)` : 리스트의 i번째 원소를 알려준다.
    - `set(i, x)` : 리스트의 i번째 원소를 x로 대체한다.
    - `indexOf(x)` : 원소 x가 리스트의 몇 번째 원소인지 알려준다.
    - `len()` : 리스트의 총 원소 수를 알려준다.
    - `isEmpty()` : 리스트가 빈 리스트인지 알려준다.
    - `clear()` : 리스트를 비운다.

오픈소스 리스트는 다 다양한 작업을 하지만 리스트의 핵심만을 파악하기 충분한 정도의 구성을 갖춘 상태로 선택하였다.   
리스트의 i번째 원소로 삽입하는 것과 맨 뒤에 원소를 추가하는 작업은 별도로 분리해두었다.

## 배열 리스트의 작업 : (1) 원소 삽입
리스트는 규칙 없이 저장되기 때문에 원소 삽입을 위해서는 **위치에 대한 정보**&ZeroWidthSpace;까지 주어져야 한다.   
- 리스트에는 원소가 `numItems` 값 만큼 저장되어 있다.
- 원소들은 배열 `item[0...numItems-1]`에 저장되어 있는 상태이다.
- 만약 `k` 번째 자리에 원소 `x`를 넣는다면, `item[k]`의 자리에 들어가야 한다.
- `item[k...numItems-1]`을 **오른쪽으로 한 칸씩 시프트한 뒤** 빈 공간을 만들어 `x`를 삽입해야 한다.
- 원소가 삽입된 이후에는 `numItems`의 **값을 1 증가시켜야** 한다.

### 원소 삽입의 ADT 구조
```
add(k, x):
    if (numItems >= item.length || k < 0 || k > numItems)
        /* 에러 처리 */ // 배열 용량을 초과했거나 부적절한 인덱스
    else
        for i <- numItems-1 downto k 
            item[i+1] <- item[i] // 오른쪽 원소부터 순서대로 우시프트를 진행
        item[k] <- x // 배열의 빈칸이 만들어지면 x를 삽입
        numItems++ // 전체 배열의 개수 증가
```

## 배열 리스트의 작업 : (2) 원소 삽입의 특수한 구조 - 맨 뒤에 원소를 삽입
뒤에 원소가 **한 개라도 존재한다면 우시프트가 진행**&ZeroWidthSpace;되지만, 원소가 없다면 시프트가 필요가 없다.   
단순히 맨 끝에 원소를 추가한 뒤에 `numItems`의 값을 1 증가시키면 된다.   
물론 `add(numItems, x)`를 사용해도 되지만 맨 끝에 값을 덧붙이는 작업은 흔하므로 따로 제공한다.

### 맨 뒤 원소 삽입의 ADT 구조
```
append(x):
    if (numItems >= item.length)
        /* 에러 처리 */
    else
        item[numItems] <- x // 맨 뒤에 x를 삽입
        numItems++ // 총 개수 값을 1 증가
```

## 배열 리스트의 작업 : (3) 원소 삭제
리스트의 원소 삭제는 두 가지 케이스로 나눌 수 있다.
- **특정 위치의 원소**&ZeroWidthSpace;를 삭제하는 경우 : 이 경우 `i`번째 원소를 삭제하고 `item[i+1...numItems]`를 좌시프트한다.
- **특정 원소**&ZeroWidthSpace;를 삭제하는 경우 : 이 경우 리스트에서 원소 `x`가 **어디에 있는지 찾아내고** 특정 위치 원소 삭제와 같은 방식으로 삭제한다.

### 특정 위치의 원소를 삭제하는 ADT 구조
```
remove(k):
    if (isEmpty() || k < 0 || k > numItems - 1) 
        /* 에러 처리 */ // 리스트가 비어 있거나 위치가 0보다 작거나 리스트 바깥인 경우
    else
        for i <- k to numItems-2 // k번째 원소부터 좌시프르를 진행
            item[i] <- items[i+1] // i+1을 i로 이동하는 것이므로 numItems-1까지 실행될 수 있음
        numItems--
```

### 특정 원소를 삭제하는 ADT 구조
```
removeItem(x):
    k <- 0
    while (k < numItems && item[k] != x) // k의 범위를 원소 x와 다른 상황의 리스트 내 범위로 한정
        k++;
    if (k == numItems) return false; // 리스트 마지막까지 갔다면 없는 원소에 대한 제거를 요청한 것
    else
        for i <- k to numItems-2
            item[i] <- items[i+1]
        numItems--
        return true
```

## 배열 리스트의 작업 : (4) 원소 값 가져오기
- 리스트의 i번째 원소의 값을 가져온다면 `item[i]`의 원소를 가져와야 함
- 범위를 벗어나는 원소의 값을 요구한다면 OutOfBound 오류를 발생해야 함

### 원소 값을 가져오는 ADT 구조
```
get(i):
    if (i >= 0 && i <= numItems-1)
        return item[i]
    else
        return OUT_OF_BOUND
```

## 배열 리스트의 작업 : (5) 원소의 값을 대체하기
- i번째 원소에 x를 지정하기만 하면 되기 때문에 대입만 하면 됨
- 범위를 벗어나는 원소의 값을 요구한다면 예외 처리를 해야 함

### 원소의 값을 대체하는 ADT 구조
```
set(i, x):
    if (i >= 0 && i <= numItems-1)
        item[i] <- x
    else
        /* 예외 처리 */
```

## 배열 리스트의 작업 : (6) 원소 x의 위치를 찾아내기
리스트에 원소 x가 포함되는지 여부를 체크하는 작업(`contains(x)`)까지 포함되어 있는 셈이다.
- 원소 x의 위치를 찾아내서 위치를 return하면 됨
- NOT_FOUND를 리턴하면 포함하지 않는 것

### 원소 x의 위치를 알아내는 ADT 구조
```
indexOf(x):
    i <- 0
    while (i < numItems && item[i] != x)
        i++
    if (i = numItems)
        return NOT_FOUND
    else
        return i
```

## 배열 리스트의 작업 : (7) 부수적인 작업들 - ADT 구조
- 총 원소 수를 알려주는 함수의 경우 변수 numItems를 리턴하면 된다.
- 리스트가 비었는지 알려주는 함수의 경우 numItems가 0인지 확인하면 된다.
- 리스트를 비우는 함수의 경우 numItems를 0으로 리셋하면 된다.
```
len():
    return numItems

isEmpty():
    if (numItems = 0)
        return true
    else
        return false

clear():
    numItems <- 0
```
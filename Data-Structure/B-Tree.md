# B-트리 (B-Tree)
## 개요
디스크의 접근은 메인 메모리 접근에 비해 드는 시간이 매우 크다. CPU 속도에 따라서 다르긴 하지만 디스크 한 블록을 읽는 데 걸리는 시간은 대략 10만~100만 개의 기계어 명령 처리 시간과 같다. 이는 CPU에서는 엄청난 낭비이다. 디스크에 있는 데이터를 읽고 쓰려면 블록 단위로 접근한다. 단 한 바이트만 읽거나 쓰려고 해도 블록을 통째로 읽어들이거나 써야 한다.

한 바이트만 집어 오는 것은 가능하지도 않을 뿐더러 한 바이트를 읽는 것이나 한 블록을 읽는 것이나 큰 차이가 없다. 어차피 암(Arm)을 해당 트랙 위로 물리적으로 이동해야 하기 때문이다. 예전에는 디스크 한 블록의 표준은 512 byte였으나 요즘은 4K byte가 표준이 된 분위기다. 이는 하지만 물리적 블록이도 파일 시스템이나 응용 프로그램에서는 얼마든지 더 큰 사이즈의 논리적 블록을 사용할 수 있다. 32K byte나 64K byte  블록도 가능하다. 이 블록을 소프트웨어 레벨에서는 주로 페이지(page)라고 부른다.

AVL 트리, 레드-블랙 트리, 이진 검색 트리는 모두 메모리에 올려서 사용한다고 가정했고 이런 색인을 내장 색인(Internal Index)라고 한다. 실제로 색인이 중요한 작업인 응용에서는 검색 트리 같은 색인을 메인 메모리에 올려놓고 사용한다. 하지만 색인의 규모가 너무 크다면 불가피하게 디스크에 두고 사용해야 한다. 메인 메모리가 충분하지 않을 때도 마찬가지이다. 설령 메인 메모리가 충분해도 어떤 응용 프로그램이 그 메모리를 다 쓸 수는 없다. 디스크에 색인을 두어야 한다면 디스크의 특성을 최대한 활용하여 디스크 접근 시간으로 인한 비효율을 최대한 줄여야 한다. 이런 동기에서 나온 대표적인 색인이 바로 B-트리인 것이다. 이렇게 메인 메모리의 외부에 놓고 사용하는 색인을 외장 색인(External Index)라고 한다.

## B-트리
검색 트리의 분기 수를 늘리면 검색 트리의 기대 깊이를 낮추는 것이 가능하다. 예를 들어, 10억 개 내외의 키 관리의 이진 검색 트리가 균형을 완벽히 갖추고 있다면 가장 이상적인 경우 30 정도의 깊이를 가지는데, 한 노드에서 1000개 정도의 분기가 가능하다면 가장 이상적인 경우 깊깊이가 4 정도면 가능하다. 검색 트리의 각 노드가 디스크에 자유로이 흩어져 있다면 전자는 디스크에 최대 30번 접근해야 하고 후자면 최대 4번이면 가능하다.

디스크에 있는 상태로 사용되는 트리인 외장 검색 트리(External Search Tree), 그리고 분기의 수가 2개를 넘는 다진 검색 트리(Multi-Way Search Tree)의 성격을 가지는 것이 B-트리인 것이다. B-트리가 한 노드에 가지는 키는 최대 $k$개이다. 키가 $k$개 있다면 이 노드는 $k+1$개의 자식을 가진다. 이 각각에 대응되는 서브 트리를 $T_0, T_1, T_2, \cdots$라고 한다면 서브 트리 $T_i$의 모든 키들은 $\text{key}_{i-1}$보다 크고 $\text{key}_i$보다 작다.

B-트리는 균형 검색 트리로서 다음 성질을 만족하게 된다.
- 루트를 제외한 모든 노드는 $\lfloor\frac{k}{2}\rfloor\sim k$개의 키를 갖는다.
- 모든 리프 노드는 같은 깊이를 가진다.

분기의 수는 가능하면 늘리지만 노드의 활용도를 높이기 위해 각 노드가 채울 수 있는 최대 허용량의 반 이상의 키를 채울 수 있게 강요한다. $k$의 값은 키를 표현하기 위한 바이트 수와 분기를 위한 레퍼런스에 필요한 바이트 수를 반영해 한 블록의 수용한도 내에서 최댓값을 잡는다. 임의의 키는 검색키와 일치했을 때 해당 키를 가진 레코드에 접근할 수 있는 페이지 번호가 같이 있어야 한다. 부모 노드의 레퍼런스 역시 하나 필요하다.

자식 노드의 레퍼런스, 부모 노드의 레퍼런스, $p_i$는 모두 페이지 번호로 나타낸다. 예를 들어 디스크의 한 블록은 4096바이트, 키 크기 16바이트, 페이지 번호가 4바이트라면 각 블록은 최대 170개의 키를 가질 수 있다. 한 노드가 최대 170개의 키를 가질 수 있는 것이다. 이 경우 아까의 성질에서 85~170개의 키를 가져야 한다. 이렇게 디스크 블록 크기와 노드 크기를 일치시키는 것은 디스크에서 정보를 읽어올 때 블록 단위로 읽어오기 때문에 최대한의 효율을 만들기 위해서이다.

메인 메모리에서 해당 레코드가 저장된 페이지의 번호를 통해 페이지를 통째로 메인 메모리로 가져와서 해당 레코드를 찾으려면 간단한 프로그램이 필요하지만 이 작업에 걸리는 시간은 디스크에서 가져오는 시간에 비해서는 무시 가능할 정도로 작다. 레코드 위치를 나타내기 위해 추가로 페이지 내 위치까지 나타낼 수도 있겠지만 이를 위한 공간이 더 필요하므로 감수할 만한 가치는 없다.

## B-트리의 알고리즘
### 검색
B-트리에서 키 `x`에 대한 검색은 이진 검색 트리의 검색과 기본적으로 같다. B-트리는 최대 $k$개의 키를 가질 수 있다는 점에서 노드의 여러 키 중 일치하는 것이 있는지 본다. 유일한 키와 비교하여 왼쪽이나 오른쪽 분기를 정하는 반면, B-트리는 $\text{key}_i-1<x<\text{key}_i$인 두 키 $\text{key}_{i-1}$과 $\text{key}_i$를 찾아 분기할 자식 노드를 찾는다. 자식으로 분기하고 나면 깊이만 하나 내려간 같은 검색 문제가 된다. 재귀적으로 처리하면 된다.

### 삽입
B-트리에서 키 `x`를 삽입하는 작업의 개략적인 골격은 다음과 같다.

- `x` 삽입의 리프 노드 `r`을 찾는다.
- 노드 `r`이 공간 여유가 있으면 키를 삽입하고 끝내면 된다.
- 노드 `r`에 여유가 없다면 형제 노드에 공간의 여유가 있는지 살펴보고 형제 노드에 공간의 여유가 있다면 키를 하나 넘기고 끝낸다.
- 형제 노드에도 여유가 없다면 노드를 2개로 분리하고, 분리 작업은 부모 노드로 키를 하나 넘기는 작업을 포함한다.

```
BTreeInsert(t, x):
    // t는 트리의 루트 노드, x는 삽입하고자 하는 키
    x를 삽입할 리프 노드 r을 찾는다
    x를 r에 삽입하는 것을 시도한다
    if (r에 오버플로우가 발생한다) clearOverflow(r)

clearOverflow(r):
    if (r의 형제 노드 중 여유가 있는 노드가 있다)
        r의 남는 키를 넘긴다
    else
        r을 둘로 분할하고 가운데 키를 부모 노드로 넘긴다
        if (부모 노드 x에 오버플로우가 발생한다) clearOverflow(x)
```

오버플로우가 발생하게 된다면 우선 키를 넘겨줄 수 있는 형제 노드가 잇는지 보고, 있으면 키를 넘겨주고 아니면 노드를 분할한다. 한 노드를 둘로 만드는 것이다. 원래는 부모 노드에 이 노드를 가리키는 하나의 레퍼런스가 있었는데 노드가 둘로 나눠지므로 부모 노드에서 이들을 구분해 분기하려면 키가 하나 더 필요하다. 그래서 분할 시 노드에 있는 키 중 하나를 부모 노드로 넘긴 다음 나머지로 분할한다. 그래서 부모 노드로 넘기는 키는 분할 노드의 키들 중 중앙값으로 하고 중앙값이 2개인 경우는 이 중 하나를 선택하는 규칙을 정한다. 이 분할의 결과로 인해 키가 하나 늘어난 부모 노드에서 오버플로우가 발생할 수 있다.

다음은 일련의 삽입 작업이다. 변화가 생긴 노드는 색으로 칠해져 있고, 각 노드는 최대 5개의 키를 가질 수 있다고 가정한다. 이 경우 B-트리의 성질에 의해 루트를 제외한 모든 노드는 2~5개의 키를 가져야 한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/32802af8-e3fb-455a-9aec-a64423d2f6de/image.png)

5를 삽입하게 되면 오버플로우가 발생하고 오른쪽의 형제 노드에 공간 여유가 있으니 키를 하나 넘긴다. 이때 6을 형제 노드에 넘기면 검색 트리의 성질이 깨지므로 부모 노드의 7을 넘기고 6을 부모 노드로 넘긴다. 이런 작업이 바로 재분배(Redistribution)이다.

![](https://velog.velcdn.com/images/aoi-aoba/post/0aef3f6d-c540-480b-a639-84fefc590443/image.png)

### 삭제
B-트리에서 키 `x`를 삭제하는 작업의 개략적인 골격은 다음과 같다.

- `x`를 키로 갖고 있는 노드를 찾는다.
- 이 노드가 리프 노드가 아니면 `x`의 직후 원소 `y`를 가진 리프 노드 `r`을 찾아 `x`와 `y`를 맞바꾼다. (직후 원소 `y`는 반드시 리프 노드에 있다.)
- 리프 노드 `r`에서 `x`를 제거한다.
- `x`를 제거한 후 노드에 언더플로우가 발생하면 적절히 해소한다.

```
BTreeDelete(t, x, r):
    // t는 트리의 루트 노드, x는 삭제하고자 하는 키, r은 x를 가진 노드
    if (x는 리프 노드가 아니다)
        x의 직후 원소 y를 가진 리프 노드를 찾는다
        x와 y를 맞바꾼다
    리프 노드에서 x를 제거하고 이 리프 노드를 r이라 한다
    if (r에서 언더플로우가 발생한다)
        clearUnderflow(r)
    
clearUnderflow(r):
    if (r의 형제 노드 중 키를 하나 내놓을 수 있는 여분을 가진 노드가 있다)
        r이 키를 넘겨받는다
    else
        r의 형제 노드와 r을 병합하고 부모의 키 하나를 넘겨받는다
        if (부모 노드 p에 언더플로우가 발생한다)
            clearUnderflow(p)
```

언더플로우가 발생할 때는 우선 키를 가져올 수 있는 형제 노드가 있는지 본다. 삽입할 때 오버플로우가 발생하면, 자신의 남는 키를 받을 수 있는 형제 노드를 보는 것과 정확히 반대이다. 그런 노드가 있다면 가져다 채우고 끝내고, 그렇지 않으면 형제 노드와 병합해야 한다. 병합은 두 노드를 하나로 합치는 것이므로 이들을 분기시켰던 부모 노드의 키가 필요 없어진다. 이 필요 없는 키와 두 노드를 합쳐 하나의 노드로 만든다. 이 병합 결과 키를 하나 없앤 부모 노드에서 언더플로우가 발생할 수 있다. 앞에서 발생한 언더플로우와 성격은 같지만 발생 장소가 다르므로 재귀적으로 처리할 수 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/4cfe7da8-022f-4427-9145-0d778d67b363/image.png)

## B-트리의 작업 성능

이진 검색 트리가 균형을 아주 잘 맞추게 된다면 높이는 $\log_2 n$에 근접할 수 있다. 마찬가지로 $d$ 진 검색 트리가 균형을 아주 잘 맞추면 $\log_d n$에 근접할 수 있다. 임의 노드가 최대 $d$ 개의 자식을 가질 수 있다면 최소한 $\lfloor\frac{d-1}{2}\rfloor+1$개(즉, 대략 $\lfloor\frac{d}{2}\rfloor$개) 자식을 가져야 한다. (루트만 예외) 그러므로 B-트리의 깊이는 최악의 경우에도 대략 $\log_{d/2} n$보다 깊을 수는 없다. 즉, 높이는 $O(\log n)$이다.

B-트리의 작업 수행 시간은 디스크 접근 횟수를 기준으로 한다. 노드를 메인 메모리에 가져온 다음, 수행한 작업에 소요하는 시간은 디스크 접근 시간에 비하면 무시할 수 있을 정도로 작기 때문에 여기서는 고려하지 않는다.

B-트리의 검색 시간은 당연히 $O(\log n)$이다. 삽입 작업은 일단 실패하는 검색을 한 번 수행해야 한다. 오버플로우가 발생하지 않으면 트리의 맨 아래에 원소 하나를 추가할 때 상수 시간이 든다. 오버플로우가 반복적으로 발생해서 루트 노드까지 파급될 수도 있으므로 트리의 높이에 비례하는 시간이 들 수 있다. 이것이 최악의 경우인데, 검색과 오버플로우 처리를 합쳐서 삽입 작업은 $O(\log n)$ 시간이 걸린다.

삭제 작업은 검색과 직접 원소를 찾는 작업에 $O(\log n)$ 시간이 든다. 언더플로우가 발생하지 않으면 노드에서 단순히 키 하나를 제거할 때 상수 시간이 드는데, 언더플로우가 반복적으로 발생하여 루트 노드까지 파급될 수 있다면 트리의 높이에 비례하는 시간이 드므로 이런 최악의 경우에는 직후 원소 찾기와 언더플로우 처리를 합해 삭제 작업은 $O(\log n)$ 시간이 든다.

B-트리의 작업 시간은 모두 '점근적'으로는 $O(\log n)$ 으로 통칭되지만, 이진 검색 트리의 $O(\log n)$에 비해 상수 인자가 상당히 작다.
# 레드-블랙 트리 (Red-Black Tree)
## 균형 검색 트리
이진 검색 트리는 검색과 삽입, 삭제에 평균적으로 $\Theta(\log{n})$ 시간이 소요되지만, 운이 나쁘면 트리의 모양이 균형을 
잘 이루지 못해 $\Theta(n)$까지 될 수도 있다. 이런 경우는 드물지만 이런 경우는 사실상 배열로 색인을 만드는 것보다 더 큰
참사가 일어난다. 그래서 고안해낸 것이 바로 균형 이진 검색 트리이다. 최악의 경우에도 이진 트리의 균형이 잘 맞도록 유지하여
작업들이 항상 $O(\log{n})$을 유지하게 하는 방법인데, 대표적으로는 AVL 트리와 레드-블랙 트리가 있다.

## 레드-블랙 트리
레드-블랙 트리는 균형을 맞추며 운영하는 대표적인 균형 이진 검색 트리이다. 레드와 블랙의 두 색을 이용하여 균형을 맞춘다고
해서 레드-블랙 트리라고 하는데, 줄여서 RB 트리로 부른다. 노드에 두 가지 색을 칠해서 균형을 맞춘다. 사실상 B-트리의 한 계열인
2-3-4 트리 (최대 4개까지 분기할 수 있는 균형 트리)와 같은 것이다.

RB 트리는 우선 `null` 리프 노드를 가정한다. 통상의 이진 검색 트리는 자식이 없으면 링크를 `null`로 두기 때문에 RB 트리는 이 `null`
각각을 리프 트리로 간주해 통상적 리프 노드 다음에 `null` 리프 노드가 한 층 더 있다고 가정하는 것이다. RB 트리에서 리프 노드라고
한다면 이 `null` 리프를 가리키는 것이고, 이는 AVL 트리에서도 사용했던 `NIL` 노드를 가리키게 하는 것이 효율적이다.

RB 트리는 모든 노드에 색상을 칠하는데, 다음과 같은 성질을 만족하도록 색을 칠해야 하는데 이를 RB 특성이라고 한다.

1) 루트는 블랙이다.
2) 모든 리프 노드[`null` 리프 노드]는 블랙이다.
3) 루트로부터 임의 리프 노드에 이르는 경로에 레드 노드 2개가 연속으로 출현할 수 없다.
4) 루트 노드에서 임의의 리프 노드에 이르는 경로에서 만나는 블랙 노드의 수는 모두 같다.

다음은 왼쪽의 이진 검색 트리를 RB 트리로 만든 예시이다.

![](https://velog.velcdn.com/images/aoi-aoba/post/a62485ef-fa08-41e4-a532-350102f4c3c4/image.png)

> 조건 1 : 루트는 블랙이다. →  맨 위 루트 노드를 블랙으로 처리   
> 조건 2 : 모든 리프 노드는 블랙이다. → NIL 노드를 모두 블랙으로 처리   
> 조건 3 : 루트로부터 임의 리프 노드에 이르는 경로에 레드 노드 2개가 연속으로 출현할 수 없다. → 레드 처리된 노드는 연속하지 않음   
> 조건 4 : 루트 노드에서 임의 리프 노드에 이르는 경로에서 만나는 블랙 노드의 수는 모두 같다. → 모두 2개의 블랙 노드를 거침

## 레드-블랙 트리의 수선
RB 트리에서하는 검색은 트리의 내용을 변경하지 않으므로 이진 검색 트리의 검색과 동일하다. 삽입이나 삭제도 기본적으로 이진 검색 트리와 동일하나, 삽입 및 삭제 후 RB 특성을 위반하는 경우가 발생할 수 있으니 적절한 작업을 통해 RB 특성을 잡아주어야 한다.

### 삽입 시 균형이 깨지는 경우의 레드-블랙 트리의 수선
우선 트리에서 노드를 삽입할 때는 이진 검색 트리의 삽입 알고리즘에 따라서 삽입을 진행한 다음, 새 노드의 색상을 일단 레드로 칠한다. 이 노드를 `x`라고 하자. 삽입에서 새 노드는 항상 맨 아래쪽에 매달린다.

![](https://velog.velcdn.com/images/aoi-aoba/post/2dbe5b81-e1f8-41f7-9dc2-75a6a6f3890e/image.png)

먼저 `x`의 부모 노드인 `p`가 블랙일 경우를 생각해보자. 위 사진은 `x`의 부모 노드가 블랙일 때 가능한 `x`의 주변 상황이다. 어떤 경우에서든 `x`에 레드를 칠한 것으로 인해 특성이 깨지지 않는다. 즉, 이때는 `x`의 색상을 레드로 칠하면 삽입이 완료된다. 그러므로 부모 노드 `p`가 레드인 경우만 해결하면 된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/ecf90613-5cdb-48da-9e4a-10a0355969cd/image.png)

`x` 노드의 부모 `p`가 레드일 때 가능한 상황은 다음과 같은데, `x`가 삽입되기 전에 `x`의 자리에는 `null` 리프가 있었으므로 조건 3과 조건 4에 따라 `x`의 형제 노드도 반드시 `null` 리프이다. `p`와 `x`가 연속으로 레드이므로 조건 3을 위반한다. 그런데 삽입 전에는 RB 트리였으므로 조건 3에 의하여 `p`의 부모 노드는 블랙임이 틀림없다. 이 노드를 `pp`라고 하자. 마찬가지로 조건 3에 의하여 `x`의 형제 노드 역시 반드시 블랙이다. 그래서 `x` 주변을 보았을 때 레드나 블랙 두 가지가 가능한 것은 `p`의 형제 노드 `s` 뿐이다. `s`의 색상에 따라 다음 두 가지로 나누자.

- case 1 : `s` 노드가 레드
- case 2 : `s` 노드가 블랙
    - case 2-1 : `x` 노드가 `p` 노드의 오른자식
    - case 2-2 : `x` 노드가 `p` 노드의 왼자식

![](https://velog.velcdn.com/images/aoi-aoba/post/3cefd965-7ce7-4ee1-a493-6328851230c4/image.png)

### CASE #1 : s 노드가 레드인 경우
`p`와 `s`의 색상을 레드에서 블랙으로 바꾸고 `pp`를 블랙에서 레드로 바꾼다. 만약 `pp`가 루트이면 `pp`의 색상을 다시 블랙으로 바꾸고 끝난다. `pp`가 루트가 아니라면 `pp`의 부모 색상을 확인해야 한다. `pp`의 부모 색상이 블랙이면 RB 특성이 모두 만족되고, `pp`의 부모 색상이 레드이면 RB 특성의 조건 3이 위반되어 처음과 같은 문제가 발생한다. 이것은 원래 `x`에 대해 발생했던 문제가 `pp`에 대해서 발생했음을 의미하므로 `pp`를 문제가 발생한 노드로 하여 재귀적으로 다시 실행한다.

### CASE #2-1 : s 노드는 블랙이고 x 노드가 p 노드의 오른자식인 경우
`p`를 중심으로 하여 왼쪽으로 회전한다. 여전히 RB 특성 조건 3을 위반하므로 Case 2-2로 변하게 된다.

### CASE #2-2 : s 노드는 블랙이고 x 노드가 p 노드의 왼자식인 경우
`pp`를 중심으로 오른쪽으로 회전하고 `p`와 `pp`의 색상을 맞바꾼다. Case 2를 만난 경우 항상 Case 2-2의 수선을 마지막으로 상황이 종료되며, Case 1을 만나면 상황이 끝날 수도 있고 같은 상황이 다른 노드에서 다시 시작될 수도 있다. 이런 상황이 재귀적으로 반복되어 루트까지 올라갈 수도 있다.

### RB 트리의 각 케이스에서의 그림 표현
![](https://velog.velcdn.com/images/aoi-aoba/post/04d92c50-9f3d-4c78-b725-5b9be7903211/image.png)

## 레드-블랙 트리의 특성
레드-블랙 트리에서는 색상을 통해 트리의 균형을 유지하기 때문에 최악읙 경우가 벌어져도 $O(\log{n})$으로 제한된다. 이유는 간단히 추론할 수 있는데, 키의 총 수가 $n$이라면 색상을 고려하지 않을 때 가장 이상적으로 꽉 채워진 트리의 깊이는 대략 $\log{n}$이다. 물론 정확히 말하면 $\lfloor\log_2{n}\rfloor+1$이지만 결론 도출에는 특별히 지장이 없으니 $\log n$으로 표시해도 큰 문제가 없다.

그러므로 RB 트리가 아무리 잘 만들어져도 루트에서 임의의 리프 노드에 이르는 경로에 존재하는 블랙 노드의 개수는 $\log n$을 넘을 수 없다. 조건 3에 의해 루트에서 임의 리프에 이르는 경로상에서 레드 노드의 수는 블랙 노드의 수보다 많을 수 없다. 그러므로 가장 긴 경로라고 해도 $2\log n$을 넘지 않으므로 깊이는 $O(\log n)$으로 제한된다. 따라서 검색 시간은 당연히 $O(\log n)$이다. 삽입과 삭제 역시 $O(\log n)$ 시간이 보장된다. 삽입의 경우만 보면 Case 2는 상수 시간에 끝나고, Case 1은 재귀 호출이므로 루트 노드에 올아갈 수도 있는데 이 최악의 경우라면 깊이가 $O(\log n)$이므로 상수 시간이 드는 작업을 $O(\log n)$번 하면 $O(\log n)$ 시간이 든다.




















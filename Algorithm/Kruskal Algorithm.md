# 크루스칼 알고리즘 : 최소 신장 트리를 찾는 알고리즘
## 최소 신장 트리(Minimum Spanning Tree)
간선의 방향이 없는 그래프에서 모든 정점들 간에 간선을 따라 서로 다다를 수 있으면 이 그래프를 '연결된 그래프(Connected Graph)' 혹은 '연결 그래프'라고 한다. 대부분의 그래프는 연결 상태를 유지하는 데 필요한 최소한의 간선보다 더 많이 가지는데, 그래프 $G=(V, E)$에서 일반적으로 $|V|-1$개의 간선을 가지면 모두 연결 상태를 가질 수 있다.

이진 검색 트리에 대해 생각해보면, 루트로부터 간선을 통해 자식들로 연결된 형태였다. 일반적으로 그래프 이론에서 트리는 '사이클이 없는 연결된 그래프'로 정의된다. 즉, 모든 트리는 $|V|-1$개의 최소한의 간선을 사용하는 것으로 유지되는 연결 그래프인 셈이다. 이렇게 정점 집합을 그대로 두고 간선을 최소한으로 남겨 트리가 되게 한 것을 '신장 트리(Spanning Tree)'라고 한다.

임의의 그래프로부터 최소 신장 트리는 꼭 하나만 만들어지진 않는다. 그리고 그래프 간선에 가중치가 있다면 신장 트리의 구성 간선 가중치를 모두 더한 합을 비용(Cost)라고 하는데, 가중치가 있는 무향 그래프 $G=(V,E)$로부터 만들 수 있는 모든 신장 트리 중에서 비용이 가장 낮은 트리를 '최소 신장 트리(Minimum Spanning Tree)'라고 한다.

## 크루스칼 알고리즘 (Kruskal Algorithm)
크루스칼 알고리즘 역시 간선이 하나도 없는 상태에서 간선을 하나씩 더해간다는 점에서 유사하다. 정점의 집합을 키워나가는 과정에서 간선의 집합도 커나간다는 점도 유사하다. 그러나 프림 알고리즘은 '하나의 정점 집합'을 점점 키워나가는 방식이지만 크루스칼 알고리즘은 '여러 정점 집합'으로 시작해서 집합들을 합쳐나가는 방식이다.

크루스칼 알고리즘은 여러 정점 집합들을 운영한다. 각 정점 집합은 싸이클이 없는 연결된 그래프로, 하나의 트리이다. 이런 두 트리를 합쳐 하나의 트리를 만들려면 양 끝점이 두 집합에 걸쳐 있는 간선이 필요하다. 이런 식으로 처음에 $n$개 트리로 시작, 두 트리를 하나로 합치는 것을 $n-1$번 시행하면 하나의 트리가 된다. 한 번 합칠 때마다 간선을 하나씩 사용하므로 총 $n-1$개의 간선이 사용되고, 이 간선들이 신장 트리를 이룬다. 다시 말하면 처음의 $n$개 트리라는 것은 각 트리가 정점 하나로만 이루어진, 간선이 없는 상태를 의미하는 것이다.

크루스칼 알고리즘의 핵심은 간선을 더하는 규칙이다. 중간의 한 시점을 귀납적으로서 살펴보면 그 시점에 구축된 서로 다른 집합(트리) 연결의 모든 간선 중 최소 비용 간선을 선택한다. 한 번에 최소 비용 간선을 하나씩 더하는데, 기존에 확정해놓은 간선의 집합과 싸이클을 만들지 않는 범위에서 더한다.

## 크루스칼 알고리즘의 형태
```
Kruskal(G):
    T <- null set
    각각 단 하나의 정점만으로 이루어진 n개의 집합을 초기화
    모든 간선을 가중치의 크기순으로 정렬해 배열 A[0...|E|-1]에 저장
    while (T의 간선 수 < n-1)
        A에서 최소 비용의 간선 (u-v)를 제거
        if (정점 u와 v가 다른 집합에 속함)
            T <- T union {(u-v)}
            정점 u와 v가 속한 두 집합을 하나로 합침
```

크루스칼 알고리즘은 먼저 모든 간선을 비용이 작은 순서로 정렬한다. 아울러 정점들을 n개 집합으로 초기화한다. 이제 비용이 가장 작은 간선부터 차례로 한 번씩 살핀다. 해당 간선이 두 정점 집합을 하나로 합칠 수 있으면 간선은 선택되어 최소 신장 트리의 일부로 확정된다. 그렇지 않으면 그 간선은 버린다.   
이런 식으로 $n-1$번의 성공적 집합 합치기가 이루어질 때까지 진행한다. 이는 $n$개의 트리로 구성된 숲(Forest)에서 궁극적으로 하나의 트리로 변해가는 과정으로 표현할 수도 있다.

## 크루스칼 알고리즘의 시각화

![](https://velog.velcdn.com/images/aoi-aoba/post/541e5299-bc4a-4ef4-84b7-06e8b8d70600/image.png)

- 처음  그래프가 먼저 주어진다. 각 정점을 하나의 집합으로 보고 7개의 집합으로 시작한다.
- 가장 작은 간선은 5이다. 이 간선을 택해 두 집합을 합쳐 하나의 집합으로 만든다.
    - 여기에서 확인한 가중치 5의 간선은 다시 보지 않고 알고리즘에서 사실상 제외한다.
- 가장 작은 간선이 7이다. 이 간선을 택해 두 집합을 합쳐 하나의 집합으로 만든다.
    - 다음 간선으로는 8을 골라야 하는데, 지금의 경우 총 3가지가 있다. 이들 중 하나를 임의로 선택한다.
- 임의로 선택한 8의 간선을 통해 두 집합을 합쳐 하나의 집합으로 만든다.
- 남은 2개 중 하나의 8의 간선을 골라 두 집합을 합쳐 하나의 집합으로 만든다.
- 남은 하나의 8의 간선을 고른 경우 양 끝점이 같은 집합에 속한다. 즉, 이 간선을 집어넣으면 기존 집합에서 사이클이 만들어지고 신장 트리에는 필요 없으므로 간선을 버린다.
- 다음으로 가장 작은 간선이 9이다. 두 집합을 하나로 합친다.
- 다음으로 가장 작은 간선이 10이다. 이 간선은 양 끝점이 같은 집합에 속하므로 사이클이 만들어짐에 따라 버린다.
- 다음으로 가장 작은 간선이 11이다. 이 간선을 고르면서 모든 정점이 하나의 집합으로 통합되며 알고리즘이 끝난다.

크루스칼 알고리즘은 다음과 같이 진행되기 때문에 작은 순서로 봄에 따라 일부 간선은 보지 않은 채 끝날 수 있다.

## 크루스칼 알고리즘의 수행 시간
```
Kruskal(G):
    T <- null set
    각각 단 하나의 정점만으로 이루어진 n개의 집합을 초기화
    모든 간선을 가중치의 크기순으로 정렬해 배열 A[0...|E|-1]에 저장
    while (T의 간선 수 < n-1)
        A에서 최소 비용의 간선 (u-v)를 제거
        if (정점 u와 v가 다른 집합에 속함)
            T <- T union {(u-v)}
            정점 u와 v가 속한 두 집합을 하나로 합침
```

다시 알고리즘을 보며 생각해보자.   
우선 모든 간선을 정렬하는 과정에서 $O(E\log E) = O(E\log V)$ 시간이 소요된다. 뒤에 있는 while 루프는 최소 $|V|-1$회, 최대 $|E|$ 회 반복된다. while 루프 안쪽을 살펴보자.   
여기에서 중요한 부분은 if문과 그 안쪽의 합치는 과정이다. 집합을 관리하는 작업들은 여러 가지 구현 방법이 있지만, 이 집합을 단순히 연결 리스트로만 구현해도 $O(E+V\log V)$ 시간으로 처리할 수 있다. 크루스칼 알고리즘의 시간은 사실상 간선의 정렬 시간에 달려 있는 것이다. 이에 따라 총 수행 시간은 $O(E\log E) = O(E\log V)$ 라고 볼 수 있겠다.

## 안전성 정리
크루스칼 알고리즘과 프림 알고리즘을 확신할 수 있는 이론적 정당성을 확인하는 한 가지의 원리를 살펴보자.

프림 알고리즘은 하나의 집합 $S$를 키워나가며 하나의 신장 트리를, 크루스칼 알고리즘은 여러 집합을 합치며 하나의 최종적인 신장 트리를 만드는 방식이다. 두 알고리즘 모두 사실상의 $n-1$개의 간선을 더하는 순서를 나름대로 정해주는 셈이다.

이렇게 더해나가는 간선이 궁극적으로 최소 신장 트리에 이르는 길을 놓치지 않아 해당 간선을 최소 신장 트리에 포함시키는 것이 안전하다는 정리가 바로 안전성 정리다.

> **안전성[무결성, 컷] 정리 (Cut Property)**   
> 간선이 가중치를 갖는 무방향 그래프 $G = (V, E)$의 정점들이 임의의 두 집합 $S$와 $V-S$로 나누어져 있다고 하자. 간선 $(u-v)$가 $S$와 $V-S$ 사이의 최소 교차 간선이면 $(u-v)$를 포함하는 그래프 $G$의 최소 신장 트리가 반드시 존재한다.

### 증명
**조건**
- $G$는 연결 그래프이며 간선에 가중치가 있다.
- $S$와 $V-S$는 임의의 두 정점 집합으로 분할한 것이다.
- $(u-v)$는 이 분할을 가로지르는(cut-crossing) 간선 중 가중치가 가장 작다.

**증명 전략**
최소 신장 트리인 트리 $T$가 이미 존재한다고 가정하고, $T$에는 간선 $(u-v)$가 포함되어 있지 않은 경우를 생각한다. 여기에서 이 간선을 강제로 포함시키는 방법이 존재함을 보이면서 이때 새로 만든 트리 역시 최소 신장 트리가 됨을 보여야 한다.

**증명 과정**
최소 신장 트리 $T$가 존재한다고 하자. $T$는 간선 집합 $E' ⊆ E$로 구성되고 $|E'| = |V| - 1$이다. 여기에서 $(u-v)$를 이미 최소 신장 트리인 $T$에 대하여 추가하게 된다면 사이클이 생길 수밖에 없다. 이 사이클에는 반드시 $S$와 $V-S$를 가로지르는 다른 간선 $(x, y)$가 존재해야 하는데, $u$는 집합 $S$, $v$는 $V-S$에 속한 원소이므로 사이클 내에 반드시 컷을 가로지르는 다른 간선이 있어야 한다.   
그런데 간선 $(u-v)$는 컷을 가로지르는 간선 중 가중치가 최소라고 가정하였기 때문에 $w(u, v) ≤ w(x, y)$이며 사이클에서 간선 $(x-y)$를 제거하고 $(u-v)$를 넣으면 새로운 트리는 $T' = T - (x, y) + (u, v)$가 되며 간선 수는 여전히 $|V|-1$이면서 연결성은 유지되며 전체 가중치는 줄어들거나 동일하게 된다. 즉, $T'$ 역시 최소 신장 트리임이 입증되며 동시에 $(u, v)$를 포함하는 최소 신장 트리가 존재함 역시 증명된다.

## 인접 행렬 방식을 활용한 Java로의 구현
```Java
public class KruskalAlgorithm {
    static int V;
    static int[] parent;

    static int find(int x) {
        // 유니온-파인드 함수에서 특정 노드의 루트(parent)를 찾음
        if (parent[x] != x) parent[x] = find(parent[x]);
        return parent[x];
    }

    static boolean union(int a, int b) {
        // 유니온-파인드 함수에서 두 정점을 같은 집합으로 묶음
        int rootA = find(a), rootB = find(b);
        // 파인드 함수로 찾아온 루트를 비교
        if (rootA == rootB) return false; // 같은 집합이면 사이클이 발생하므로
        parent[rootB] = rootA; // 다른 집합일 때만 합친다
        return true;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();

        StringTokenizer st = new StringTokenizer(br.readLine());
        V = Integer.parseInt(st.nextToken());
        int E = Integer.parseInt(st.nextToken());

        int[][] graph = new int[V][V];
        for (int i = 0; i < E; i++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            graph[u][v] = graph[v][u] = w;
        }
        // 위쪽은 입력을 받는 부분이므로 크게 변화하지 않음

        List<int[]> edges = new ArrayList<>();
        for (int i = 0; i < V; i++)
            for (int j = i + 1; j < V; j++)
                if (graph[i][j] != 0) edges.add(new int[] {i, j, graph[i][j]});
        // u, v, w 형태로 간선을 저장

        edges.sort(new Comparator<int[]>() {
            @Override
            public int compare(int[] e1, int[] e2) {
                return Integer.compare(e1[2], e2[2]);
            }
        }); // 모든 간선을 가중치 크기순으로 정렬해서 저장

        parent = new int[V];
        for (int i = 0; i < V; i++) parent[i] = i;
        // 각 정점이 자기 자신을 대표로 가지면서 각각의 정점을 하나의 집합으로 간주

        int total = 0;
        List<int[]> mst = new ArrayList<>();
        for (int[] e : edges) {
            if (union(e[0], e[1])) {
                total += e[2];
                mst.add(e);
            }
        }
        // 간선을 하나씩 살펴보며 유니온-파인드 함수로 보내고 집합 합친 경우만 최소 신장 트리로

        mst.sort(new Comparator<int[]>() {
            @Override
            public int compare(int[] e1, int[] e2) {
                if (e1[0] != e2[0]) return Integer.compare(e1[0], e2[0]);
                else return Integer.compare(e1[1], e2[1]);
            }
        });

        sb.append("Edge \tWeight\n");
        for (int[] arr: mst)
            sb.append(arr[0]).append(" - ").append(arr[1]).append("\t").append(arr[2]).append("\n");
        sb.append("Total Weight: ").append(total);

        System.out.println(sb);
    }
}
```


# 알고리즘 수행 시간
- 알고리즘의 효율성 기준인 '자원 사용의 효율적인 정도'
- 가장 대표적인 자원인 **시간을 기준으로** 표현
- 입력의 크기 **n에 대해 시간이** 얼마나 걸리는지로 표현
- 입력 크기는 정렬할 원소의 수, 색인에 포함된 원소의 수, 함수에 들어가는 자연수의 크기 등으로 **자명하게** 나타남

## 알고리즘 예시
```
algorithm1(A[], n):
	k ← n/2;
	return A[k]
```
n을 2로 나눈 값을 k에 할당하고 배열 A에서 A[k] 값을 리턴하는 알고리즘이므로 n의 크기와 무관하게 **상수 시간**&ZeroWidthSpace;이 소요된다.

```
algorithm2(A[], n):
	sum ← 0
    for i ← 0 to n-1
    	sum ← sum + A[i]
	return sum
```
배열 A의 모든 원소를 더하는 알고리즘인데, 나머지 부분은 무관하고 for loop에서 시간이 가장 많이 소모된다. for loop가 **n번 반복** 실행되면서 내부에서는 단순히 덧셈만 하므로 상수 시간이 소요되어 수행 시간은 **n에 비례한다.**

```
algorithm3(A[], n):
	sum ← 0
    for i ← 0 to n-1
    	for j ← 0 to n-1
    		sum ← sum + A[i] * A[j]
	return sum
```
배열 A의 모든 원소 쌍의 곱을 합산하는 알고리즘으로, for loop가 2번 중첩되어 총 $$n^2$$번 반복되고 각 루프에서는 단순 계산이 진행되어 상수 시간 작업이 수행됨에 따라 수행 시간은 **$$n^2$$에 비례한다.**


```
algorithm4(A[], n):
	sum ← 0
    for i ← 0 to n-1
    	for j ← 0 to n-1
    		k ← A[0...n-1]에서 임의로 n/2개를 뽑은 것들 중 최댓값
            sum ← sum + k
	return sum
```
for loop를 $$n^2$$번 반복되고 매번 배열에서 반을 임의로 뽑아서 최댓값을 계속 더하는 알고리즘이다. 크기 n의 배열에서 임의로 n/2개를 뽑으며 최댓값을 구하는 것은 **n/2에 비례하는 시간**&ZeroWidthSpace;이 들며, 이는 **n에 비례한다** 라고 표현해도 무방하다. 결과적으로 알고리즘의 수행 시간은 **$$n^3$$에 비례한다.**

```
algorithm5(A[], n):
	sum ← 0
    for i ← 0 to n-2
    	for j ← i+1 to n-1
            sum ← sum + A[i] * A[j]
	return sum
```
배열 A[0...n-1]에서 i < j인 모든 원소 쌍의 곱을 합하는 알고리즘인데, 중첩 구조지만 반복 횟수가 **매번 가변적인** 이중 for loop이다. 결국은 for loop가 시간을 좌우하며, i=0이면 안쪽은 n-1회, i=2이면 안쪽은 n-2회, ..., i=n-2이면 안쪽은 1회 반복된다. 결국 n-1부터 1까지의 합이므로 $$\frac{n(n-1)}{2}$$이 되어 수행 시간은 **$$n^2$$에 비례한다.**   

하지만 위와 다르게 자기호출 구조가 조금 복잡해진다면 알고리즘의 수행 시간 분석도 복잡해진다. 그래서 수행 시간이 **지배적으로 나타나는 부분** 구별하는 작업이 가장 중요하며, 입력의 크기 n에 대해 어떻게 비례하는지 관계성을 파악하는 것이 다음이다.

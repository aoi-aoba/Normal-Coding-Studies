# 이진 검색 트리 (Binary Search Tree)
## 검색 트리
이진 검색 트리는 이진 트리의 속성을 그대로 받기 때문에 각 노드가 최대 2개까지 가지를 칠 수 있다. 맨
위에 있는 노드를 **루트(Root)**&ZeroWidthSpace;라고 하며, 우리말로 '뿌리'라는 뜻이다. 트리는
한 분기점에서 최대 2개까지 분기할 수 있는 나무이다. 3개 이상 분기할 수 있는 트리는 **다진 검색
트리**&ZeroWidthSpace;라고 부른다. 즉, $N$개의 자식 노드를 가진다는 것이다. $N$진 검색 트리라
하면 **자식을 최대 $N$개까지 가질 수 있는** 검색 트리를 의미한다.

검색 트리는 저장되는 장소에 따라 **내장 검색 트리와 외장 검색 트리**&ZeroWidthSpace;로 분류할 
수 있다.
- **내장 검색 트리** : 검색 트리가 메인 메모리 내에 존재
- **외장 검색 트리** : 검색 트리가 외부(주로 디스크)에 존재

메인 메모리에서 검색 트리 전체를 수용할 수 있다면 메인 메모리에 한 번만 탑재한 후 내장 검색 트리로
사용할 수 있다. 어떤 프로그램이든 **메인 메모리 전체를 검색 트리에 사용할 수는 없다.** 시스템에서
기본적으로 사용하는 공간이 있고 다른 프로그램도 사용하므로 한 프로그램이 사용할 수 있는 메인 메모리
용량에 **검색 트리 전체를 두는 것이 불가능한 경우가 발생**&ZeroWidthSpace;한다. 그러면 디스크
공간에 저장된 상태로 검색해야 한다. 이런 외장 검색 트리는 대부분 디스크 접근 시간이 검색 효율을
좌우한다.

## 이진 검색 트리
이진 검색 트리에는 다음과 같은 특성이 있다.
> (1) 각 노드는 킷값을 하나씩 가지며 각 노드의 킷값은 모두 다르다.   
> (2) 최상위 레벨에 루트 노드가 있고 각 노드는 최대 2개의 자식 노드를 가진다.   
> (3) 임의 노드 킷값은 자신 왼쪽 아래의 모든 노드의 킷값보다 크고 오른쪽 아래의 모든 노드의 
> 킷값보다 작다.

![](https://velog.velcdn.com/images/aoi-aoba/post/b4683723-aa52-4c4d-997e-8008f6a2cb42/image.png)

위 사진을 보면, 이진 검색 트리의 예시가 있다. 왼쪽 위의 킷값이 30인 노드가 루트 노드이다. 30보다 
작은 키들 10, 20, 25는 다 노드 30의 좌측에 있고, 30보다 큰 키들 35, 40, 45는 다 노드 30의 우측에
있다. 오른쪽의 트리는 같은 키들의 집합으로 만들어진 이진 검색 트리인데, 킷값이 40인 노드가 루트
노드이다. 왼쪽 트리는 균형이 잘 잡혀 있고, 오른쪽 트리는 그다지 균형이 잡힌 상태가 아니다. 그 결과
트리의 높이가 좌측은 3, 우측은 4이다. **검색 트리의 높이는 효율성에 큰 영향을 미친다.**

검색 트리 내에 존재하는 부분적인 트리를 **서브 트리**&ZeroWidthSpace;라고 한다. 좌측 트리의
루트 노드 30에 대한 왼쪽/오른쪽의 서브 트리가 그림에 제시되어 있다.

## 노드 객체의 구조
이진 검색 트리의 각각의 노드를 객체로 만들어보자. 트리 그림의 동그라미 각각이 노드이다. 임의의 
노드를 하나의 객체로 할 때, 다음과 같은 구조로 만들 수 있다.
- **필드** : `item`, `left`, `right`
    - `item` 필드는 키를 저장한다.
    - `left` 필드는 노드의 왼쪽 자식을 의미한다.
    - `right` 필드는 노드의 오른쪽 자식을 의미한다.
- **메소드** : `setItem()`, `getItem()`, `setLeft()`, `getLeft()`, `setRight()`, `getRight()`
    - 만약 필드를 접근 불가능하게 `private` 한정사를 활용하게 된다면 외부 접근 메소드가 필요하다.

하나로 더 알아볼 것이 `pageNumberOfRecord`이다. 거색 트리에서 검색이 성공했을 때 해당 키를 가진
레코드에 접근할 수 있는 정보가 있어야 한다. 그래서 이진 검색 트리의 노드는 레코드의 위치에 관한
정보를 가져야 하지만, 레코드 접근은 단순한 일이고 검색 트리를 만들고 키로 검색하는 과정에 레코드
접근 정보는 사용되지 않아 약식으로 무시하고 표현한다. 하지만 궁극적으로는 색인은 레코드 접근의
목적을 가지며 위치 정보는 편의상 나타내지 않을 뿐이다.

## 이진 검색 트리 객체의 구조
이제 노트의 구조가 되어 있으니, 이진 검색 트리도 구성할 수 있다. 이진 검색 트리 객체는 다음과 같은
구조로 만들 수 있다.
- **필드** : `root`
    - 루트 노드를 의미하는 `root`만이 유일하게 필요한 필드이다.
    - 추가적으로 총 몇 개의 원소가 있는지 `numItems` 정도를 사용할 수도 있다.
- **메소드** : `search()`, `insert()`, `delete()`, `isEmpty()`, `clear()`
    - `search(x)` : 원소 x를 검색한다.
    - `insert(x)` : 원소 x를 삽입한다.
    - `delete(x)` : 원소 x를 지운다.
    - `isEmpty()` : 검색 트리에 키가 하나도 없이 비어 있는지 확인한다.
    - `clear` : 트리를 비운다.

대략적인 코드 골격은 다음과 같다.
```java
public class BinarySearchTree {
    private TreeNode root;
    
    public BinarySearchTree {
        root = null;
    }
    
    public Treenode search(...) { ... }
    public void insert(...) { ... }
    public void delete(...) { ... }
    ...
}
```
이진 검색 트리는 `BinarySearchTree` 객체 하나와 `TreeNode` 객체들로 만들어진다. 이진 검색 트리
객체가 루트를 레퍼런스하고, 다른 노드들은 이 루트에서 링크로 연결된다.
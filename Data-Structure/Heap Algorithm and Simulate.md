# 배열을 이용한 힙 구조
## 힙의 객체 구조
힙을 위한 배열 `A[0...n-1]`을 활용하자.
임의의 힙 구조에 대해서 하나의 객체(Class)로서 정의된다고 했을 때, 구조는 다음과 같다:
- **필드** : `A[]`, `numItems`
    - `A[]` : 힙을 저장하는 배열
    - `numItems` : 힙의 원소 수를 저장
- **메소드** : `insert(x)`, `deleteMax()`, `buildHeap()`, `max()`, `isEmpty()`, `clear()`
    - `insert(x)` : 힙에 원소 x를 삽입
    - `deleteMax()` : 힙의 최대 원소를 알려주며 삭제
    - `buildHeap()` : 배열 A[]를 힙으로 가공
    - `max()` : 힙의 최대 원소를 알려줌
    - `isEmpty()` : 힙이 비었는지 알려줌
    - `clear()` : 힙을 깨끗이 청소함

## 힙의 작업 : (1) 원소 삽입
힙에 새 원소를 삽입하려고 한다면, 일단 맨 끝에 추가하고 올라가면서 수선한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/fb785d1f-41eb-4372-b4de-53c36ea4a691/image.png)

1. 새로 추가하려고 하는 신규 아이템(원소)를 **맨 끝에** 붙인다.
    - 사진의 경우, 신규 아이템 7을 붙인다.
2. 자식의 노드 값이 **부모의 노드 값보다 작다면** 둘을 맞바꾼다.
    - 사진의 경우, 자식의 노드 값(7)이 부모의 노드 값(18)보다 작으므로 바꾼다.
    - 바꾼 뒤에도, 자식의 노드 값(7)이 부모의 노드 값(9)보다 작으므로 바꾼다.
3. 더 이상 비교해서 바꿀 조건이 나오지 않는다면 그대로 둔다.
    - 사진의 경우, 루트 위치에 있는 5보다 작지 않다. 그대로 두고 작업을 마친다.

이런 작업을 **스며오르기(Percolate Up)** 작업이라고 한다.   
노드 `A[i]`를 부모 값과 비교해서 힙 특성을 깨면 둘의 자리를 바꾼다. 바뀐 부모를 자신의 부모와 비교,
힙 특성을 만족하지 않으면 또 다시 바꾼다. 이를 힙 특성을 만족하는 최초의 지점까지 또는 더 이상 
위로 올라갈 수 없을 때까지 반복한다. 노드 `i`로부터 시작한 작업은 부모와 비교해서 자리 바꾸는
수고를 덜고 나면 성격은 같지만 자리가 하나 위로 올라간 스며오르기 작업을 만난다.   
즉, 이 과정에서 **스며오르기 작업은 재귀적 작업** 종류에 해당함을 알 수 있다.

### 힙 원소 삽입 알고리즘
```
insert(x): // 힙 A[0...n-1]에 원소 x 삽입
    i <- n
    A[i] <- x
    parent <- (i - 1) / 2
    while (i > 0 and A[i] > A[parent])
        A[i] <-> A[parent] // swap
        i <- parent
        parent <- (i - 1) / 2
    n++ // 힙 크기 1 증가
```
비재귀 버전의 알고리즘을 아래와 같이 재귀 버전으로 바꿀 수도 있다.

```
insert(x): // 힙 A[0...n-1]에 원소 x 삽입
    A[n] <- x
    percolateUp(n)
    n++ // 힙 크기 1 증가

percolateUp(i): // 힙 특성을 만족하게 A[0...i] 수선 (A[0...i-1]은 힙 특성 만족)
    parent <- (i - 1) / 2
    if (i > 0 and A[i] > A[parent])
        A[i] <-> A[parent] // swap
        percolateUp(parent)
```

## 힙의 작업 : (2) 원소 제거
힙으로 대표되는 우선순위 큐의 삭제 원소는 우선순위 값이 가장 큰 원소를 대상으로 한다. 힙에서는
가장 큰 원소가 루트에 있으므로 무조건 `A[0]`이 사라지는데, 무작정 이걸 지워버리면 나머지는
끊어진 두 개의 트리게 되므로 완전 이진 트리는 될 수 없다. 그래서 맨 끝 원소를 옮기고 버린다. 그래서
자리를 옮긴 `A[0]`가 자식들과 관련해 힙 특성을 깰 수도 있기 때문에 수선이 필요하다.

1. 주어진 힙에서 먼저 루트 노드에 맨 마지막 노드를 복사한다.
   - 값이 루트 노드에 오고, 맨 마지막의 노드 자체를 버려 `A[0...N-1]`로 크기가 하나 줄었다.
2. `A[0]`을 시작으로 하여 스며내리기 작업을 실행해 리프 노드에 다다를 때까지 진행한다.
3. 위에서 값이 내려온 노드가 리프 노드일 때 삭제 작업을 마친다.

이런 작업을 **스며내리기(Percolate Down)** 작업이라고 한다.   
화분에 준 물이 제자리로 스며들어갈 때 어떤 값은 스며들다가 정지하고, 어떤 값은 처음 자리에서 
움직이지 않고, 어떤 값은 끝까지 내려갈 수 있다. 스며내리기 직전에는 루트의 두 서브 트리가 힙 특성을
만족하고 있다는 전제가 있다.

### 힙 원소 삭제 알고리즘
```
deleteMax(): // 최댓값을 힙에서 알려주면서 삭제한다
    max <- A[0]
    A[0] <- A[n-1]
    n-- // 힙 크기 1 갑소
    percolateDown(0)
    return max

// A[k]를 루트로 하는 서브 트리가 A[k...n-1] 범위 내에서 힙 특성을 만족하게 수선
// 주어진 조건으로서 A[k]의 두 자식을 루트로 하는 서브 트리는 힙 특성을 만족함

percolateDown(k):
    child <- 2k+1   // 왼쪽의 자식 노드
    right <- 2k+2   // 오른쪽의 자식 노드
    if (child <= n-1)
        if (right <= n-1 and A[child] < A[right])
            child <- right  // A[2k+1]과 A[2k+2] 중 더 큰 원소의 인덱스
        if (A[k] < A[child])
            A[k] <-> A[child]   // swap
            percolateDown(child)
```

## 힙의 작업 : (3) 힙 생성
모든 배열은 완전 이진 트리로 간주할 수 있기 때문에, `A[0...8]` 배열의 첫 번째 원소인 `A[0]`은 힙의 
루트에 해당하고, 맨 마지막 원소인 `A[8]`은 맨 마지막 리프 노드에 해당한다. 그렇기 때문에 거꾸로 
올라가서 보면 가장 최초로 리프 노드가 아닌 것은 `A[3]`이고 이것은 맨 마지막 노드 `A[8]`의 부모 
노드이다. 앞에서 부모 노드를 구하는 식에도 해당한다.

이제 힙 조건 2를 만족하도록 수선해보자.
- 수선은 맨 마지막 노드(리프 노드)의 부모부터 시작
- 이 노드를 루트로 하는 서브 트리를 힙으로 수선
- 서브 트리의 루트가 되는 노드를 하나씩 앞으로 이동하면서 서브 트리를 힙으로 수선
- 최종적으로 `A[0]`이 루트가 되는 서브 트리는 전체 트리이므로 이 트리를 수선하면 모든 배열을 힙으로 수선하는 과정이 끝남

![](https://velog.velcdn.com/images/aoi-aoba/post/37be9201-66fd-4843-9d9f-a3fca4f4a077/image.png)

여기에서 주목할 점이 있다면
- 임의의 노드를 루트로 해서 수선하는 과정은 스며내리기를 한 번 하는 것
- 수선의 기준 노드는 맨 끝 노드의 부모 노드를 시작으로 해서 루트로 이동하면서 기준이 됨
- 자식 노드가 두 개 있다면 두 노드 중에서 더 큰 노드와 비교하고 스며내리기로 리프 노드까지 진행
- 이 과정에서 스며내리기를 하는 시점에 이 노드의 자식들을 루트로 하는 서브 트리들은 힙으로 수선되어 있음

### 힙 생성 알고리즘
```
buildHeap(): // 배열 A[0...n-1]을 힙으로 만든다
    for i <- (n-2)/2 downto 0
        percolateDown(i)
```

## 기타 작업
힙의 최댓값을 알아보는 함수 `max()`
```
max():
    if (isEmpty()) /* 에러 처리 */
    else return A[0]
```

힙이 비었는지 여부를 확인하는 함수 `isEmpty()`
```
isEmpty():
    if (n = 0) return true
    else return false
```

힙을 비우는 메소드 `clear()`
```
clear():
    n <- 0
```

## 힙 수행 시간
힙의 작업 수행 간에 가장 자주 하는 작업은 두 원소의 비교이다.

### 힙 만들기
힙 크기가 `n`이라고 하면 힙 만들기에는 $\theta(n)$ 시간이 든다. 얼핏 $O(n \log{n})$ 시간이 들지 않나 생각할 수도 있지만, 
`buildHeap()`의 수행 시간은 각 `percolateDown()`의 수행 시간을 합한 것이다. `percolateDown()`은 두 자식의 값들 중에서
큰 값을 찾아 자신과 비교하기 때문에 한 레벨에서 두 번의 원소 비교가 이루어진다. 즉, 최대 비교 횟수는 서브 트리 높이와 
비례하게 된다. `buildHeap()`은 맨 뒤에서부터 노드를 훑으면서 `percolateDown()`을 한다. 하지만 전체의 반은 리프 노드라서
아예 시간을 쓰지 않고 스킵한다. 대략 `n/2`개 이다. 대략 `n/4`개의 노드는 높이 2인 서브 트리의 루트가 되어 최대 2번 비교가
진행된다. 그 다음 대략 `n/8`개의 노드는 높이 3인 서브 트리의 루트가 되어 최대 4번 비교가 진행된다.  이런 식으로 대부분의
노드가 전혀 비교하지 않거나 극히 작은 횟수로 비교하게 된다. 힙의 높이인 $\log{n}$에 비례하는 경우는 매우 적다. 그래서 이
횟수와 경우의 수를 곱해 가중평균하면 $\theta(n)$의 시간복잡도를 유도해낼 수 있다.

### 원소 삽입
`insert()`는 `A[n]`에서 시작하는 한 번의 `percolateUp()`이 전부이므로 $O(\log{n})$ 시간이 든다. 리프 노드에서 시작해서
올라가면서 자신의 부모와 비교하는 일을 반복하는데, 최악의 경우 루트 노드까지 올라갈 수 있기 때문이다. 운이 좋으면 물론 한
번에 끝날 수도 있다.

### 원소 제거
`deleteMax()`는 `A[0]`에서 시작하는 한 번의 `percolateDown()`이 전부이므로 $O(\log{n})$ 시간이 든다. 리프 노드에
가깝게 진행될 때 까지 가면 $\log{n}$에 비례하는 시간이 들고 중간에 멈추면 그보다 더 적은 시간이 든다. 힙의 모든 원소가
동일할 경우 맨 위 레벨에서 비교하는 작업만 하고 끝나 상수 시간이 든다.

## JAVA 구현 간 Comparable 인터페이스
제네릭 클래스의 파라미터를 `<E>` 대신 `<E extends Comparable>`을 사용한다.
- 파라미터 타입 `E`가 `Comparable` 인터페이스를 만족
- 타입 `E`의 객체들 간 비교가 가능해야 할 때, 단순 비교 연산자는 기초(primitive) 타입이 아니면 불가능
- 이 경우 `compareTo()` 메소드를 활용하여 두 객체를 비교할 수 있게 해야 함
- `x.compareTo(y)`가 양수이면 `x`가 더 크고, 음수이면 `y`가 더 크고, 같으면 `0`이 리턴된다.

## 구현
JAVA를 활용해 구현한 코드는 Normal-Coding-Studies/Data-Structure-With-JAVA/Data-Structure/out/production/Data-Structure/heap 내에 있다.

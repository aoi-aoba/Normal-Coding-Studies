# 삽입 정렬(Insertion Sort) 알고리즘
선택 정렬, 버블 정렬과 정반대로 착상한 정렬 알고리즘

## 삽입 정렬의 아이디어
선택 정렬이나 버블 정렬에서는 정렬되지 않은 배열의 크기를 n부터 시작해 하나씩 줄여나가는데, 삽입
정렬은 **정렬된 배열의 크기를 1에서 시작하여 하나씩 늘려나간다.** 핵심 작업은 이미 정렬된 `i`개의
배열에 하나의 원소를 **더해나가면서 정렬된** `i+1`개짜리 배열을 만드는 것이다. 아래의 그림을 
보면서 선택 정렬의 아이디어를 알아보자.

![](https://velog.velcdn.com/images/aoi-aoba/post/fdb07ce3-bc38-42f5-bffa-0aa75881ac6e/image.png)

삽입 정렬의 정렬 과정 중 한 단계이다. 앞에서부터 5개까지 이미 정렬이 되어 있는 한 지점에서, 색칠된
부분까지는 이미 정렬되어 있다. 그러면, 그 다음 원소를 체크해서 제자리를 찾기 위해 값을 보면서 적절한
자리에 위치하도록 11보다 큰 수를 **한 자리씩 이동,** 제자리에 끼워 넣어 정렬된 6개짜리의 배열을
얻는다. 이런 작업을 **맨 앞부터 반복하가는 것이** 삽입 정렬의 방식이며 반복할 때마다 크기는 1씩
증가하게 된다. 아래 그림을 보면서 더 정확한 로직을 파악해볼 수 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/d05afd75-72f1-4704-9765-5f97459f27d0/image.png)

## 삽입 정렬의 알고리즘
```
insertionSort(A[], n):
    for i <- 1 to n-1
        A[0...i]의 적합한 자리에 A[i]를 삽입한다
```
조금 더 자세히 기술하자면...
```
insertionsSort(A[], n):
    for i <- 1 to n-1
        j <- i-1;
        newItem <- A[i]
        while (0 <= j and newItem < A[j])
            A[j+1] <- A[j] // 좌시프트
            j--
        A[j+1] <- newItem
```

## 삽입 정렬의 수행시간
삽입 정렬의 수행 시간은 for, while 루프를 제외하면 사실상 상수 시간 작업들이다.
- for 루프는 `n-1`번 순환한다.
- while 루프의 순환 횟수는 두 수의 비교 횟수와 비례한다.
  - while 루프는 최대 i-1번 순환한다.
  - 운이 좋으면 `A[i]`의 자리에 그대로 위치하므로 비교 횟수 1회, 순환 없음
  - 운이 나쁘면 `A[0]`의 자리까지 이동해야 하므로 비교 횟수 `i`회, 순환 `i-1`회

최악의 경우 $\frac{n(n-1)}{2}$의 수행 시간으로, 여기에서 최고차항이 2차인 함수가 나타남에 따라 
시간 복잡도가 $\Theta(n^2)$의 형태로 나타난다. 보통의 경우에서는 `A[0...i-1]`에서 평균적으로 절반
정도를 훑게 되므로 전체 비교 횟수는 최악에 대해 절반 정도 된다. 이 경우에도 상수 배밖에 차이가 나지
않으므로 여전히 최고차항은 2차인 상태이다.

## 삽입 정렬의 특징
삽입 정렬은 최악의 경우 $\Theta(n^2)$에 해당하는 비효율적 정렬 알고리즘군에 해당한다. 하지만, 
배열이 거의 정렬된 상태로 입력된다면 **가장 매력적인 알고리즘** 중 하나이다. 배열이 완전히
정렬된 상태라면 while 루프가 **단 한 번의 원소 비교로 수행되지 않으므로** $\Theta(n)$으로
해결될 수 있다. 배열이 **거의 정렬되어 있을 때도** $\Theta(n)$에 수렴하게 된다. 그래서 다른
방식으로 정렬된 형태에 가깝게 만들고 삽입 정렬을 수행하면 진행이 굉장히 빨라지는데, 이 방식을
활용한 것이 셀 정렬이다. 이후에 다뤄보자.

최악의 경우와 평균적인 경우에는 $\Theta(n^2)$, 최선의 경우 $\Theta(n)$의 시간 복잡도를 가지며,
다른 조건이 없는 경우 단순한 수행 시간으로서는 $O(n^2)$이라고 해야 한다. 선택 정렬이나 버블 정렬
보다는 많이 빠른 편이다.

삽입 정렬은 일반적으로 수학적 귀납법의 원리를 따르게 된다. 먼저 배열의 크기가 1일 때는 정렬되어
있고, 동시에 정렬할 것이 없다. 왼쪽에 크기 `k`인 배열이 정렬되어 있다면 (즉, `A[0...k-1]`) 적절한
삽입에 의하여 크기가 `k+1`인 배열도 정리된다. 이로써 삽입 정렬이 제대로 정렬된다는 것이 귀납적으로
증명된다.

## 구현
JAVA를 활용해 구현한 코드는 Normal-Coding-Studies/Data-Structure-With-JAVA/Data-Structure/src/Data-Structure/sort 내에 있다.
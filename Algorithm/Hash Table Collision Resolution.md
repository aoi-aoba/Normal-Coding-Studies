# 해시 테이블의 충돌 해결
어떤 키가 이미 자리잡은 상태에서 다른 키가 동일한 해시에 삽입을 시도하는 것을 충돌(Collision)이라고 한다. 동일한 주소에 2개 이상의 키가 해싱되는 상황인데, 이런 경우 충돌 해결(Collision Resolution)의 방법으로서는 체이닝(Chaining)과 개방 주소 방법이 있다.

## 체이닝(Chaining)
체이닝은 충돌을 일으킨 키들을 연결 리스트로 관리하는 방법이다. 즉, 같은 주소로 해싱되는 키를 모두 하나의 연결 리스트에 매달아서 관리한다. 해시 테이블 크기가 $m$일 때 최대 $m$개의 연결 리스트가 존재할 수 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/b32b618d-b4c9-49dc-862e-a82fdb023e41/image.png)

체이닝에서 임의의 키를 삽입할 때는 해싯값이 가리키는 연결 리스트에 삽입한다. 이때, 리스트의 맨 앞에 삽입하는 것이 좋다. 맨 끝에 삽입할 수도 있지만 번거롭다. 키를 검색할 때는 해당 연결 리스트의 키를 차례로 지나가며 찾는다. 일례로, 위에서 94를 찾으면 바로 찾을 수 있다. 42를 검색한다면 3번 주소의 94, 3을 탐색하고 42를 찾는다. 삭제할 때도 연결 리스트에서 해당 키를 찾아 삭제한다.

```
insert(x):
    리스트 table[h(x)]의 맨 앞에 x를 삽입

search(x):
    리스트 table[h(x)]에서 x값을 가지는 키를 검색

delete(x):
    리스트 table[h(x)]에서 x의 노드를 삭제
```

체이닝은 적재율이 1을 넘어도 사용할 수 있다는 장점이 있다.

## 개방 주소 방법(Open Addressing)
개방 주소 방법은 체이닝과 달리 추가 공간은 사용하지 않고, 충돌이 일어나도 어떻게든 주어진 테이블 공간에서 해결한다는 점에 이점이 있다. 그래서 모든 키가 자신의 해시 값에 일치하게 주소에 할당된다는 보장이 없다는 단점도 존재한다.

개방 주소 방법에서 먼저 어떤 키를 받아오면 해시 함수를 계산하고 다른 키가 없다면 그 자리에 넣을 것이다. 이때, 그 자리에 다른 키가 있는 충돌 상황을 가정하자. 그러면 정해진 규칙에 의해 다음 자리를 찾는데 빈자리가 나올 때까지 계속 찾는다. 이를 순차적 해시 함수로 볼 수 있다. 즉, 처음 계산한 것을 0번 해시 함수, 두 번째 계산하는 것을 1번 해시 함수, 또 충돌해서 세 번째 계산하는 것을 2번 해시 함수... 와 같이 볼 수 있다. 이를 $h_0(x)$, $h_1(x)$, $h_2(x)$와 같이 표현하며, 이 중 $h_0(x)$는 기본 해시 함수 $h(x)$를 의미하게 된다.

```
insert(x):
    i <- 0
    repeat
        j <- h_i(x)
        if (table[j] = null or table[slot] = DELETED)
            table[j] <- x
            return j
        else i++
    until (i = m)
    error // 테이블 오버플로우

search(x):
    i <- 0
    repeat
        j <- h_i(x)
        if (table[j] = x) return j
        else i++
    until (table[j] = null or i = m)
    return NOT_FOUND

delete(x):
    i <- 0
    repeat
        j <- h_i(x)
        if (table[j] = x)
            table[j] <- DELETED
            break
        else i++
    until (table[j] = null or i = m) 
```

`repeat-until` 루프가 개방 주소 방식에서 다음 해시 함수를 계속 계산하여 다른 자리를 확인한다. 모든 함수에 이 루프가 있다. 개방 주소 방법은 테이블에 주어진 공간만 사용할 수 있으므로 적재율이 1을 넘지 않으며 적재율이 어느 정도 이상 높아지면 효율이 급격히 떨어지므로 적당한 임계점을 설정하여 그 임계점을 넘으면 해시 테이블의 크기를 2배로 키우는 것이 일반적이다. 테이블 크기가 바뀌면 해시 함수가 바뀌므로 모든 키를 다시 해싱해야 한다.

### 개방 주소 방법에서의 삭제
충돌이 일어나면 바로 다음 자리를 보는 가장 간단한 선형 탐색 방법을 기반으로 편의상 설명해보자.

![](https://velog.velcdn.com/images/aoi-aoba/post/d7c95300-0cba-4ae6-92d8-4396fe583d57/image.png)

키들이 저장된 가장 왼쪽 상황에서 키 1을 삭제하여 중간 상황으로 오게 된다. 여기서 키 38을 검색하게 된다면 주소 12에 매핑되는데, 이미 키 25가 자리잡아 충돌이 일어난다. 빈자리가 보일 때까지 다음 자리를 계속 보는데 12, 0을 거쳐 주소 1에 이르면 빈자리를 발견해 키 38은 없다고 판단한다. 그런데 키 38은 이미 주소 6에 할당되어 있다. 키 38의 저장 과정에서 주소 12, 0, 1, 2, 3, 4, 5를 거쳤으므로 이와 같은 과정을 밟아야 하는데 도중에 1이 삭제되면서 1을 거쳐갈 수 없는 것이다. 이와 같은 과정을 방지하기 위해서 원래 키가 있었던 자리였음을 표시하기 위해 `DELETED`라는 상숫값을 저장하여 자리를  표시하는 맨 오른쪽과 같이 저장하여 주소 6까지 이동하여 38 키를 찾을 수 있는 것이다. 실제 키가 아닌 상수를 저장하면 공간 사용 효율이 나빠지진 않나 궁금할 수 있는데, 삽입 과정에서 상수 `DELETED`를 만나면 그 자리에 키를 넣으며 사라지므로 우려할 정도는 아니다.

## 개방 주소 방법의 충돌 해결 방법
### 선형 탐색 (Linear Probing)
가장 간단한 충돌 해결 방법으로, 충돌이 일어난 바로 뒷 자리를 참고하는 방식이다. 엄밀히 말하면 충돌이 일어난 자리에서 `i`에 관한 일차함수의 보폭으로 점프하나 흔히 일차함수의 대표로 그냥 `i`를 사용한다. 이렇게 하면 `i`번째 해시 함수 $h_i(x)$는 $h(x)$로부터 `i`만큼 떨어진 거리가 된다. 테이블 경계를 넘으면 맨 앞으로 가면 된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/80f6e35a-4a24-4d80-a60b-608195961ec5/image.png)

- 처음에 주어진 입력은 다음과 같으며 해시 함수는 `h(x) = x % 13`을 사용하였다.
    > 25, 13, 16, 15, 7, 28, 31, 20, 1, 38
- 28까지의 입력은 그저 해시 함수를 활용하여 해결할 수 있다.
- 31의 입력이 들어온다. `31 % 13 = 5`이므로 5번 주소에 31이 삽입된다.
- 20의 입력이 들어온다. `20 % 13 = 7`이므로 7번 주소를 보면 7이 이미 삽입되어 충돌이 일어난다. 다음 주소 8에 20이 삽입된다.
- 1의 입력이 들어온다. 1번 주소는 비어 있으므로 그대로 삽입할 수 있다.
- 38의 입력이 들어온다. `38 % 13 = 12`이므로 12번 주소를 보면 이미 25가 있다. 12는 마지막 자리이므로 주소 0을 다음 주소로 하여 계속 충돌이 일어나 다음 자리로 향하다 보면 비어 있는 6번 주소에 삽입된다.

정리하면, 선형 탐색에서 `i`번째 해시 함수는 다음과 같다.

> $h_i(x) = (h(x) + ai + b) \bmod m$ (단, 이때 $i = 0, 1, 2, \cdots$)

여기서는 a, b 값의 대표로 1, 0을 사용하였다. 첫 해시 함숫값은 $h(x) = h_0(x)$이다. 선형 탐색의 경우 특정 영역에 키가 몰릴 때는 치명적으로 성능이 떨어지는데, 이런 현상을 1차 군집(Primary Clustering)이라고 한다. 1차 군집의 중간에 새 키가 해싱되면 해당 주소부터 차례로 훑어야 하기때문에 탐색 횟수가 많이 늘어난다. 영역이 커질 수록 해당 영역에 해싱될 확률이 커지므로(즉, 충돌할 확률이 커지므로) 군집이 심하지 않은 영역에 비해 영역의 크기가 빨리 커진다. a, b 값을 적절히 조정한다고 해도 1차 군집 현상은 존재하게 된다.

### 이차원 탐색(Quadratic Probing)
이차원 탐색은 바로 뒤 대신 보폭을 이차 함수에 의해 넓히면서 본다. 예를 들면, $h_i(x)$를 $h(x)$로부터 $i^2$만큼 떨어진 자리로 삼을 수 있다. 즉, $h(x), h(x)+1, h(x)+4, h(x)+9, \cdots$와 같이 볼 수 있다. 이차원 탐색 방법의 `i`번째 해시 함수는 다음과 같다.

> $h_i(x) = (h(x) + ai^2 + bi + c) \bmod m$ (단, 이때 $i = 0, 1, 2, \cdots$)

가장 대표적인 이차 함수로 $i^2$을 사용하게 된다면 1차 군집이 생겨 특정 영역에 키가 몰린다 해도 빠르게 그 영역을 벗어날 수 있다. 1차 군집 영역이 아래와 같이 주어지면, 선형 탐색 방법은 네 번 만에 군집 영역을 벗어나야 하지만 $i^2$은 두 번 만에 군집 영역을 벗어날 수 있고, a와 b의 값을 키우면 더 빨리 벗어날 수도 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/a04ff33d-171a-4f8f-a5e9-f2a72ab9aed1/image.png)

물론 오른쪽과 같이 단점도 생긴다. 여러 개의 키가 동일한 초기 해시 함숫값을 가지면 같은 순서로 탐색되므로 비효율을 피할 수 없다는 것이다. 이런 현상을 2차 군집(Secondary Clustering)이라고 한다. 15, 28, 41, 67, 54의 순서로 해싱하게 된다면 모두 주소 2로 해싱되기 때문에 키 54는 테이블 경계를 지나서 다섯 번 만에 빈 자리를 찾게 된다. 보폭은 점점 넓어지지만 이차원 탐색으로 인한 이득을 보지 못한다.

### 더블 해싱(Double Hashing)
더블 해싱은 2개의 함수를 사용한다. `i`번째 해시 함수는 다음과 같이 설정된다.

> $h_i(x) = (h(x) + if(x)) \bmod m$ (단, 이때 $i = 0, 1, 2, \cdots$)

서로 다른 해시 함수인 $h(x)$와 $f(x)$를 사용하여 충돌이 생기면 다음에 볼 주소를 계산할 때 두 번째 해시의 함숫값만큼 점프하게 된다. 두 키의 첫 번째 해싯값이 같아도 두 번째 함숫값이 같을 확률이 매우 작아 서로 다른 보폭에 점프하여 2차 군집 문제가 발생하지 않는다.

![](https://velog.velcdn.com/images/aoi-aoba/post/4afd9f3d-ff16-41b5-996d-c2e2ab008777/image.png)

다음과 같이 2차 군집 문제가 발생하지 않음을 알 수 있다. 그래서 2개의 해시 함수를 정할 때 권장하는 방법은 소수 $m$에 대하여 $h(x) = x \bmod m$으로 잡고, $m$보다 조금 작은 소수 $m'$에 대하여 $f(x) = 1 + (x \bmod m')$으로 잡는 것이다. 좀 더 큰 예시로 $(m, m') = (1601, 1597)$ 정도로 생각해볼 수 있다.

더블 해싱에서도 유의할 점이 있다면, 두 번째 해시 함숫값 $f(x)$가 해시 테이블 크기 $m$과 서로소여야 한다. 만일 $f(x)$가 $m$에 대하여 1보다 큰 최소공약수 $d$를 가지게 된다면 $x$의 자리를 갖기 위해 해시 테이블 전체 중에 기껏해야 $1/d$밖에 보지 못하게 된다. 위의 예시처럼 $m$을 아예 소수로 잡으면 $f(x)$가 양수이기만 하면 되기 때문에 항상 서로 소가 되므로 이 조건은 그리 만족하기 어렵진 않다.

> **왜 그럴까?**   
> 더블 해싱에서 키 $x$에 대한 탐색 순서는 $h(x),\ h(x) + f(x),\ h(x) + 2f(x),\ \dots$와 같이 $f(x)$씩 더하면서 충돌을 피한다. 이때 $f(x)$와 테이블 크기 $m$이 서로소가 아니고 공약수 $d > 1$이 존재하면, $h(x) + i \cdot f(x) \bmod m$의 결과는 $m$칸 전체를 순회하지 못하고 $m/d$개의 위치만 탐사하게 된다. 이는 전체 테이블의 $1/d$만큼만 확인 가능하다는 뜻으로, 충돌 해결 실패 확률이 높아져 해시 테이블의 성능이 크게 저하된다. 반면 $f(x)$와 $m$이 서로소이면 모든 위치를 빠짐없이 순회할 수 있어 충돌 해결이 원활하다.

## 해시 충돌 해결 방법에 따른 검색 기대 시간

체이닝 방법을 이용하는 해싱에서 적재율이 $\alpha$일 때, 탐색 횟수의 기대치는 $\alpha$에 비례한다. (적재율이 $\alpha$이면 각 리스트에 저장된 키 수의 기댓값은 $\alpha$이다.) 개방 주소 방법의 이론적 성능은 체이닝보다 못하다. 체이닝의 경우 각 키가 자신이 해시된 주소에만 저장되므로 다른 주소에는 영향을 전혀 미치지 못하지만, 개방 주소 방법에서는 자신이 해시되지 않은 주소에 저장될 수도 있으므로 복잡해진다. 적재율 $\alpha$인 개방 주소 해싱에서 검색 실패 경우의 탐색 횟수 기대치는 $\frac{1}{1-\alpha}$ 이하이다. (단, $0≤\alpha≤1$) 검색이 성공할 경우 탐색 횟수의 기대치는 $\frac{1}{\alpha}\log{\frac{1}{1-\alpha}}$ 이하이다. 이들 값은 $\alpha$가 1에 가까워질수록 급속히 커진다.

이론적으로는 체이닝이 개방 주소 방식보다 좋다. 개방 주소 방식의 경우 자신과 최초 해싯값이 같지 않은 키라도 검색 과정에서 방해를 할 수 있다. 충돌이 일어나면 자신의 최초 해싯값이 아닌 다른 주소에 어떻게든 자리를 잡기 때문이다. 이에 반해 체이닝은 충돌을 일으킨 키만 같은 연결 리스트에 매달아 충돌을 일으키지 않은 키끼리는 검색에 지장을 주지 않는다. 그렇지만 이 이론적 성질이 낫다고 체이닝이 더 매력적인 것은 아니다. 체이닝은 각 연결 리스트마다 헤드를 둬야 하고 연결 리스트를 만들기 위해 각 키마다 연결을 위한 공간이 필요하다. 따라서 적재율이 별로 높지 않다면 개방 주소 방법이 유리하다.

개방 주소 방법은 적재율이 1을 절대로 넘진 않으나 체이닝은 제한이 없다. 그렇지만 어떤 경우든 적재율이 높으면 해싱 효율이 떨어지므로 적절히 낮은 적재율을 유지할 필요가 있다. 개방 주소 방법의 경우는 분모로 인해서 적재율 상한을 $\alpha = 0.5$로 하고 경계치로 설정한다. 이 경계치를 넘으면 해시 테이블 크기를 2배 가까이 키워서 다시 해싱하여 저장한다.
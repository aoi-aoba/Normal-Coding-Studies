# 힙(Heap)
## 우선순위 큐
Unix, Linux, Windows 등 모든 OS는 작업(process)들의 우선순위를 부여하여 이들을 관리한다. CPU나 
다른 자원을 무겁게 사용하면서 며칠 동안 수행해야 할 작업은 대폭 우선순위를 낮추고 작업할 수 있다. 
우선순위 큐를 정의하고 그 대표적인 자료구조로 힙을 알아보도록 하자. 우선순위의 부여 기준은 다양한데,
선착순도 대표적인 우선순위 부여 방법이다. **우선순위를 가진 원소를 삽입할 수 있고 가장 큰 원소를 
빼줄 수 있으면 우선순위 큐(Priority Queue)**&ZeroWidthSpace;라고 한다.   

```
원소를 삽입한다.
최대 원소를 알려주면서 삭제한다.
최대 원소를 알려준다.
우선순위 큐가 비어 있는지 확인한다.
우선순위 큐를 비운다.
```
다음은 우선순위 큐의 추상 데이터 타입(ADT)이다. 앞의 세 개는 우선순위 큐의 핵심 작업이고, 뒤의 두 
개는 자료구조에 거의 공통으로 들어가는 작업이다.   
우선순위 큐는 임의의 값을 가진 **원소를 검색하는 기능은 필요 없다.** 우선순위가 가장 높은 것을 
그저 알려주고 삭제할 수 있으면 된다. 연결 리스트, 스택, 배열, 리스트, 큐와 같이 한 줄로 관리할 수 
있는 것을 **선형 자료구조** 형태라 하는데, 우선순위 큐도 물론 선형 자료구조로 나타낼 수 있긴
하지만 우선순위가 높은 원소를 내줄 수만 있으면 된다.

## 트리 구조와 이진 트리(Binary Tree) 구조
**이진 트리(Binary Tree)** 구조에 대해 알아보자. 그래프 이론에서 트리는 
**사이클을 만들지 않는 연결된 그래프** 형태이다. 직관적으로, 위에서 아래로 부모-자식(Parent-Child)
관계로만 이어진 것을 의미한다. 부모라고 해서 둘이 아니고 **노드 하나를** 지칭하는 말이다.

![](https://velog.velcdn.com/images/aoi-aoba/post/ccf8a6a9-0de6-41b8-bdb8-7f35f4ba7fc7/image.png)

트리는 부모-자식 관계가 여러 층 반복되기도 하고 부모 하나에 여러 자식이 매달릴 수도 있다. 맨 위의
노드(A)를 **루트(Root)** 라고 한다. 반대로 뒤집었을 때 나무 형태가 되는 트리의 뿌리 부분에 해당하는
결과인 것이다. 루트는 **부모 노드가 없는 유일한 노드**&ZeroWidthSpace;이다.

모든 노드가 2개 이하의 자식을 갖는 트리를 **이진 트리(Binary Tree)**&ZeroWidthSpace;라고 한다.
즉, 나무가 한 분기의 점에서 **최대 2개까지만 분기** 가능한 구조이다. 힙은 이진 트리구조이다. 
이진 트리 중에서 완전 이진 트리 구조를 가지는데, 이를 설명하기 전에 포화 이진 트리 구조를 알아보자.

## 포화 이진 트리 구조 (Full Binary Tree)
![](https://velog.velcdn.com/images/aoi-aoba/post/aa125a4c-f0d0-4b95-98b8-1503105eed6d/image.png)

포화 이진 트리는 **모든 노드가 정확히 자식 노드를 2개씩 가지며** 꽉 채워진 트리이다. 자식이 하나도
없는 노드를 **리프 노드(Leaf Node)** 혹은 **말단 노드(Terminal Node)** 라고 한다. 포화 이진
트리에서는 모든 리프 노드(말단 노드)가 **맨 아래 레벨** 위치에 존재한다. 포화 이진 트리에서는
위의 사진과 같이 노드의 총 수가 1, 3, 7, 15, ... 와 같이 $2^k-1$개 존재해야 한다. 총 수가 이들 중
하나가 아니라면 포화 이진 트리가 아니다.

## 완전 이진 트리 구조 (Complete Binary Tree)
![](https://velog.velcdn.com/images/aoi-aoba/post/d82a21a5-55b8-4dce-af8d-68eaefab0f96/image.png)

완전 이진 트리 구조의 경우 노드 수가 맞지 않아 포화 이진 트리를 만들 수 없을 때 최대한 포화 이진
트리에 가깝게 만든 것이다. 노드 수가 안 맞을 때, **왼쪽부터 차례로 채운** 것이 완전 이진 트리
구조이다. 맨 마지막 레벨 전까지는 모든 노드가 자식을 2개씩 가지고, 채우지 못한 경우는 왼쪽부터
차례로 채우는 것이다. 여기에서 설명할 힙 구조는 모두 **완전 이진 트리** 구조에 해당해야 한다.

## 힙 구조의 조건
힙 구조는 다음 조건을 만족해야 한다.
> 1. 힙은 완전 이진 트리(Complete Binary Tree) 구조여야 한다.
> 2. 힙 특성(Heap Property) : 모든 노드는 값을 갖고, 자식 노드 값보다 크거나 같다.

조건 2의 힙 특성을 갖추면 우선순위가 큰 원소가 루트에 위치하게 되는데, 이런 힙을 특히
**최대 힙(Max Heap)** 구조라고 부른다. 이 특성과 대조가 되는 힙도 있다. 노드의 값이 자식 노드
값보다 **작거나 같은** 힙이 있는데, 이를 **최소 힙(Min Heap)** 구조라고 한다. 최소 힙의 경우
루트에 가장 작은 원소가 루트에 위치하게 된다. 대소만 바뀌었을 뿐 성질은 동일하므로 최대 힙으로
제한하여 설명한다. 힙에는 동일한 값이 여러 개 저장되어도 상관없다.

![](https://velog.velcdn.com/images/aoi-aoba/post/876f7772-841e-49e2-9a63-e69e250f355f/image.png)

10개 원소로 이루어진 힙의 예시이다. 모든 노드가 자식 노드보다 크거나 같은 값을 가져 힙 특성을
만족하는 형태이다. 이들의 값은 트리 옆의 배열처럼 저장할 수 있다. **임의의 배열은 항상 완전 이진
트리로서** 해석할 수 있다. 배열이 `A[0]`보터 시작된다면 `A[k]`의 자식은 `A[2k+1]`과 `A[2k+2]`이다.
그림에서는 `A[1]`부터 사용하였고, `A[k]`의 자식은 `A[2k]`와 `A[2k+1]`이다.

완전 이진 트리는 **왼쪽부터 빈 노드 없이 꽉 채우는 것이 기본** 조건이기 때문에, **배열의 인덱스**
값을 활용해 간단히 계산할 수 있다. 완전 이진 트리가 아닌 이진 트리는 부모-자식 노드 계산 규칙을
적용할 수 없다. 완전 이진 트리에서 부모 노드를 찾는 것도 가능한데, `A[k]`의 부모 노드는
인덱스가 $\lfloor\frac{k}{2}\rfloor$ 로 나타난다. 물론, 위의 사진처럼 `A[1]`로 시작하는 경우는
$\lfloor\frac{k-1}{2}\rfloor$로 나타난다.

임의 배열 하나가 주어지면 완전 이진 트리로 간주할 수 있으므로 자동으로 조건 1이 만족되는데, 배열
값들이 2를 만족할 확률은 거의 없으므로 조건 2인 힙 특성을 만족하게 수선하는 것이 힙을 만드는 과정의
전부이다.

## 힙 객체의 구조
우선순위 큐를 만드는 방법은 유일하지 않지만 가장 대표적인 수단이 힙이다. 힙을 구현하는 수단으로서
배열을 사용하자.

임의의 힙 구조에 대해서 하나의 객체(Class)로서 정의된다고 했을 때, 구조는 다음과 같다:
- **필드** : `A[]`, `numItems`
    - `A[]` : 힙을 저장하는 배열
    - `numItems` : 힙의 원소 수를 저장
- **메소드** : `insert(x)`, `deleteMax()`, `buildHeap()`, `max()`, `isEmpty()`, `clear()`
    - `insert(x)` : 힙에 원소 x를 삽입
    - `deleteMax()` : 힙의 최대 원소를 알려주며 삭제
    - `buildHeap()` : 배열 A[]를 힙으로 가공
    - `max()` : 힙의 최대 원소를 알려줌
    - `isEmpty()` : 힙이 비었는지 알려줌
    - `clear()` : 힙을 깨끗이 청소함
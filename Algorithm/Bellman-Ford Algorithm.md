# 벨만-포드 알고리즘(Bellman-Ford Algorithm)
## 최단 경로
네비게이션에 목적지를 입력하면 가장 효율적인 경로를 알려주는데, 어떤 목적지로 갈 때 주로 최단 거리 혹은 최단 시간이 소요되는 경로를 알려주게 된다. 이런 최단 경로(Shortest Path) 구하기 문제는 가중치가 있는 방향 그래프에서 자주 사용된다. 그래프 $G=(V, E)$에서 $E$가 가중치를 가진 방향 간선들의 집합일 때 임의 경로는 연속된 간선들로 이루어진다. 즉, 간선들의 체인이다. 경로를 구성하는 간선들의 가중치 합을 해당 경로의 길이라고 한다.

최단 경로 문제에서 입력 유형은 주로 두 가지이다. 첫째는 모든 간선 가중치가 음이 아닌 일반적인 경우로, 현실 지도를 그래프로 표현하면 이에 해당하고 이는 주로 다익스트라 알고리즘으로 풀이한다. 다른 하나는 음의 가중치가 존재하고 이를 허용하지만 가중치 합이 음인 사이클은 절대 허용하지 않는 경우로, 이는 주로 벨만-포드 알고리즘으로 풀이한다. 음의 사이클이 있으면 해당 사이클을 몇 번이고 반복해 돌아 경로의 가중치 합을 무한정으로 낮출 수 있으므로 문제 자체가 성립할 수 없다.

다익스트라 알고리즘과 벨만-포드 알고리즘은 하나의 시작 정점으로부터 다른 모든 정점에 이르는 최단 경로를 구한다. 이에 반해 모든 정점 쌍 간의 최단 경로를 구하는 알고리즘도 있다. 앞의 유형은 단일 시작점 최단 경로 문제, 뒤의 유형은 모든 쌍 최단 경로 문제라고 한다. 여기서는 단일 시작점 최단 경로 문제로 한정한다. 임의의 두 정점 간 경로가 존재하지 않는 경로의 길이는 $\infty$, 즉 무한대로 정의한다. 즉 가중치가 $\infty$인 간선이 있다고 가정하는 것인데 이는 매우 자연스러운 가정이다.

## 벨만-포드 알고리즘이 다익스트라 알고리즘과 다른 점
다익스트라 알고리즘은 음의 가중치가 있는 경우를 해결하지 못한다. 최단 경로를 구하는 데 음의 가중치를 왜 고려해야 하나 의문이 들 수도 있다. 하지만 생각보다 간단하다. 최단 경로를 구하기 위해 거쳐가면 좋을 장소가 있다면 그 장소를 지나는 도로는 보상을 줄 만하다. 이때 그 구간에 음의 가중치를 주는 것이다. 그러면 지나가는 것을 유도할 수 있다.

예를 들어, A에서 B까지 가는 도중에 기름이 부족해질 수 있으니 C를 갔다가 가게 하고 싶다. 그렇다면 필요한 정도에 따라 음의 가중치를 두면 간선을 포함하는 경로를 구할 때 도움이 된다. 네트워크의 데이터 패킷의 최단 경로를 계산할 때도 이렇게 음의 가중치를 주면 좋은 경우가 존재한다. 그래서 벨만-포드 알고리즘은 이론적으로도 중요한 위치를 차지한다. 동적 프로그래밍의 대표적 예시인데, 알고리즘의 핵심 주제 중 하나이다.

## 벨만-포드 알고리즘의 형태
```
BellmanFord(G, r):
    // G는 주어진 그래프, r은 시작 정점
    for each u in set V
        u.cost <- INF
    r.cost <- 0
    for i <- 1 to n-1
        for each (u, v) in set E
            if (u.cost + w_uv < v.cost)
                v.cost <- u.cost + w_uv
                v.prev <- u
    for each (u, v) in set E
        if (u.cost + w_uv < v.cost)
            output "해 없음: 음의 사이클"
```

벨만-포드 알고리즘은 코드가 가장 간단한 알고리즘 중 하나이다. 위 알고리즘에서 맨 마지막 for 루프는 음의 사이클 존재 여부를 확인하는 부분이다. 즉, 문제가 성립하는지 보는 것이니 최단 경로를 구하는 것과 상관 없다. 직전 정점을 기록하는 `v.prev <- u` 역시 최단 경로 구하기와 무관하다. 즉, 이들을 제외한 이중 for 문이 핵심이다.

```
for i <- 1 to n-1
    for each (u, v) in set E
        v.cost <- min{v.cost, u.cost + w_uv}
```

이 부분을 살펴보자. `i=k`로 for 루프를 수행한 직후 `v.cost`에는 최대 $k$개의 간선을 사용해 `v`에 이르는 최단 경로가 계산된다. 처음의 for 루프가 끝나면(총 $n-1$번) 최대 $n-1$개의 간선을 사용하는 최단 경로가 계산되며, $n-1$개를 초과하는 경로는 의미가 없다. 간선 수가 $n-1$개인 경로에는 $n$개의 모든 정점이 다 포함된다. 간선의 수가 $n-1$개를 초과하면 두 번 이상 포함되는 정점이 생겨 당연하게도 사이클이 만들어진다. 모든 사이클은 0 또는 양수이므로 최단 경로에 넣어도 도움이 될 수 없다. 그러므로 $n-1$개의 간선을 포함하는 최단 경로보다 짧은 경로는 존재할 수 없다는 것이 보장된다.

for 루프를 시작하기 직전에는 간선을 하나도 사용하지 않고 이르는 최단 경로만이 저장되어 시작 정점 자신을 제외한 모든 곳은 $\infty$로 저장된다. 처음 한 번 돌면 하나의 간선을 사용해서 이를 수 있는 최단 경로가 계산된다. 즉 시작 정점에서 직접 연결된 점들의 최단 거리에 변동이 생긴다. 맨 마지막 반복을 통해 루프가 끝나면 최대 $n-1$개의 간선을 사용해 이를 수 있는 최단 경로가 계산된다. 이것이 최단 경로이다. 이는 동적 프로그래밍(Dynamic Programming, DP)의 방식을 그대로 따르고 있기 때문에 그 대표적 예시가 될 수 있다.

## 벨만-포드 알고리즘의 시각화

![](https://velog.velcdn.com/images/aoi-aoba/post/ba46a42d-cf2c-48ad-b3cd-d9c3aac811aa/image.png)

벨만-포드 알고리즘의 작동 예시를 보자.
- 처음에 그래프가 주어진다. 시작 정점 $r$의 최단 거리만 0으로 세팅하고, 나머지는 $\infty$로 초기화한다.
- 모든 간선을 한 번씩 확인하고, 해당 간선으로 인해 앞에서 설정한 최단 경로가 더 짧아질 수 있는지 확인한다. 여기에서는 시작 정점에서 연결된 세 정점에 대해 최단 거리가 8, 9, 11이 가능하다.
- 모든 간선을 다시 한 번씩 살피며 해당 간선으로 인해 앞에서 설정된 최단 거리가 더 짧아질 수 있는지 확인한다. 앞에서 3개의 정점에 변동이 생겼으므로 이들로부터의 연결된 정점에 변동을 확인한다. 이들의 최단 거리가 -6, 10, 19, 19로 바뀐다. -6으로 바뀐 정점은 아까도 8로 바뀌었지만 최단 거리 9로부터 연결되어 있어 다시 -6으로 바뀐다.

이런 식으로 계속 매 for 문 회전 마다 간선을 살피며 최단 거리의 변동을 확인하는 것이다. 마지막에는 아무 변동이 일어나지 않았는데, 시작 정점에서 7개 간선 사용의 최단 경로는 없다는 의미이다. 즉 가장 많은 수의 간선을 사용하는 최단 경로는 6개 간선을 사용하는, 최단 경로 3의 정점이다.

벨만-포드 알고리즘에서 음의 사이클이 존재하는 그래프가 입력으로 들어오게 된다면 for 루프의 체크를 통과하지 못하고 아예 최단 경로를 만들 수 없게 된다.

## 수행 시간
```
BellmanFord(G, r):
    // G는 주어진 그래프, r은 시작 정점
    for each u in set V
        u.cost <- INF
    r.cost <- 0
    for i <- 1 to n-1
        for each (u, v) in set E
            if (u.cost + w_uv < v.cost)
                v.cost <- u.cost + w_uv
                v.prev <- u
    for each (u, v) in set E
        if (u.cost + w_uv < v.cost)
            output "해 없음: 음의 사이클"
```
벨만-포드 알고리즘의 수행 시간은 간단하다. 이중 for 문의 첫 for 문은 $\Theta(V)$회 반복된다. 두 번째 for문은 $\Theta(E)$회 반복된다. 이 안에 있는 작업들은 상수 시간이 든다. 따라서 이 전체 for 문에서 $\Theta(VE)$ 시간이 소요되고, 앞뒤로 있는 단독적인 for 문은 점근적 시간 복잡도에 영향을 주지 않게 된다.

물론 이 시간은 단축할 수 있다. `for each (u, v) in set E`의 부분에서 모든 간선을 하나씩 살피게 해서 그런데, 사실은 바로 앞 단계에서 `u.cost`에 변동이 생긴 `u`라는 정점에 대해서만 `u`의 진출 간선을 살피면 된다는 것이 자명하고 이런 성질을 이용해 평균적으로 효율이 높아지게 수정하면 수행 시간은 $O(VE)$까지 끌어낼 수 있다. 다만 평균 $O(E \log V)인 다익스트라 알고리즘에 비해서는 시간이 많이 걸리므로 음의 가중치 문제가 아니라면 다익스트라 알고리즘으로 해를 구하는 것이 바람직하다.
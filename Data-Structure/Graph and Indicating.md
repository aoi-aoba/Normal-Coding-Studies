# 그래프와 그 표현
## 그래프(Graph)
그래프는 어떤 현상이나 사물을 정점과 간선으로 표현한 것이다.
- 정점(Vertex) : 대상이나 개체를 표시
- 간선(Edge) : 정점 간의 관계를 표시

### 간선과 가중치
간선은 두 도시를 연결하는 도로의 존재 여부, 인터넷 사이트들 간의 하이퍼 링크 여부, 사람들 간 행동 패턴의 유사성, 뇌세포 간의 연결성 등을 나타낼 수 있다. 이런 간선 그래프에 가중치를 두게 되면 그 정도나 거리, 시간, 용량 등의 정확한 수치를 나타낼 수 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/daa72bb8-d7ba-4a31-946e-b726cdbec673/image.png)

### 방향성
간선에 방향성의 개념이 들어가면 선후 관계, 공급 관계, 링크나 흐름의 방향 등을 표현할 수 있다. 이렇게 방향이 들어가게 되는 것을 방향 그래프(Directed Graph), 없는 것을 무향 그래프(Undirected Graph)라고 한다. 단순히 그래프라 하면 대개 무향 그래프를 가리키며, 무방향 그래프라고도 한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/ffcf326b-fa45-4af5-bf4e-97aa186e982b/image.png)

### 정점과 간선의 표현
정점 집합 $V$와 간선 집합 $E$로 구성된 그래프 $G$를 보통 $G = (V, E)$라고 표시한다.   
정점의 총 개수 $|V|$는 흔히 소문자 $n$으로 표시한다.   
정점 $u$와 $v$를 잇는 간선은 보통 $\{u, v\}$ 혹은 $(u, v)$로서 표시한다.   
관행적으로 $\{u, v\}$는 무방향의 간선을, $(u, v)$는 방향 간선을 나타낸다.    
조금 더 직관적인 표현을 위해 $(u-v)$ 혹은 $(u→v)$를 사용하기도 한다.

## 그래프의 표현
### 인접 행렬을 활용한 표현
그래프 $G=(V, E)$에서 정점의 총수 $n$에 대하여 $n×n$ 행렬을 준비한다. 정점 $i$와 정점 $j$ 사이의 간선이 존재하면 행렬의 $(i, j)$ 원소 혹은 $(j, i)$ 원소의 값을 1로 할당한다. 간선으로 연결된 두 정점을 인접한 정점(Adjecent Vertex)이라고 한다. 이런 식으로 간선에 대응되는 자리에 1을 할당, 나머지 자리에는 0을 할당하는 것이다.

아래 두 예시는, A~F의 정점을 각각 0~5까지의 인덱스로서 할당하여 관계를 나타낸 것이다.

![](https://velog.velcdn.com/images/aoi-aoba/post/fd0dc09c-7ce8-410f-af0a-1c07cbb00d77/image.png)

다음 사진은 왼쪽의 가중치 없는 무향 그래프를 인접 행렬(Adjacency Matrix)로 표현한 것이다. 행렬에서 0이 아닌 원소의 수는 간선 총 수의 2배이다. 가중치가 있다면 1 대신 가중치를 저장하면 된다. 무향 그래프를 인접 행렬로 나타내면 대각선을 기준으로 대칭 행렬이 된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/5928fe02-7b9b-4c37-bbde-9c177c3b87ef/image.png)

다음 사진은 왼쪽의 가중치가 부여된 방향 그래프를 인접 행렬로 표현한 것이다. 간선에 방향이 있으므로 위와 달리 대칭은 아니다. 행렬에서 0이 아닌 원소의 수가 간선의 총 수와 같으며, 세로줄이 출발하는 인덱스, 가로줄이 도착하는 인덱스이다.

장점
- 이해가 쉽고 간선의 존재 여부를 즉각 알 수 있음
- 인접 여부는 (i, j) 원소나 (j, i) 원소를 확인하면 알 수 있음

단점
- $n×n$ 배열을 필요로 하며 $n^2$에 비례하는 공간이 필요함 → 공간 복잡도 $\Theta(n^2)$
- $n^2$ 미만의 시간이 소요되는 알고리즘에 사용하면 행렬 준비 과정에서만 $\Theta(n^2)$ 시간이 필요

→ 간선의 밀도가 아주 높은 그래프에서는 인접 행렬 표현이 적합 (정점 개수로 만들어지는 칸에 대해 0을 많이 채워야 하는 경우는 부적합함함)

### 인접 리스트를 활용한 표현
인접 리스트(Adjacency List)는 각 정점에 인접한 정점을 리스트로 표현하는 방법이다. 각 정점마다 리스트를 하났기 만드는데, 일반적으로 연결 리스트를 사용한다. 각 정점마다 인접한 정점들을 하나의 연결 리스트에 매다는 것이다. 존재하지 않는 간선은 리스트에 나타나지 않는다.

![](https://velog.velcdn.com/images/aoi-aoba/post/ad0fbfab-48ef-425c-908c-5f388c71f92f/image.png)

다음은 인접 리스트로 표현한 두 그래프이다. 단순 관계 그래프인 경우 간선 하나에 대해서 노드가 2개씩 만들어지며, 각 노드는 <정점 번호, 다음 정점으로 가는 링크> 형태로 구성된다. 이와 같은 무방향 그래프에 사용되는 인접 리스트 표현 내에서 필요한 총 노드 수는 총 간선 수의 2배이다. 정점 i, j가 서로 인접하면 정점 i의 연결 리스트에 j가, 정점 j의 연결 리스트에 i가 포함되어 한 간선당 노드가 2개씩 만들어지기 때문이다. 아래는 가중치가 더해진 형태인데, 정점 번호와 다음 노드로 가는 링크에 더해 간선의 가중치를 저장하는 부분이 추가된다. 즉, <정점 번호, 가중치, 다음 정점으로 가는 링크> 형태로 구성된다.

장점
- 공간이 간선의 총 수에 비례하는 양만큼만 필요하다.
- 대체로 인접 행렬보다는 공간 낭비가 적다.
- 가능한 모든 정점 쌍에 비해 간선의 수가 적은 '희소 그래프(Sparse Graph)' 형태일 때 유리하다. 

단점
- 거의 모든 정점 쌍에 대한 간선이 존재한다면 오버헤드만 더 드므로 인접 행렬보다 불리하다.
- 정점 i와 j 사이 간선 존재 여부를 리스트로 차례로 훑어야 하므로 인접 행렬보다 체크하는 데 시간이 오래 걸린다.
- 간선이 많은 경우 인접성의 한 번의 체크에 대해 최악의 경우 $n$에 비례하는 시간이 걸린다.

→ 간선의 밀도가 비교적 적은 희소 그래프(Sparse Graph) 형태에는 인접 리스트가 적합

### 인접 배열을 활용한 표현
인접 리스트처럼 간선의 수에 비례하는 공간을 쓰면서 인접 리스트보다 간선 존재 여부를 훨씬 빨리 체크할 수 있는 방법이 있다. 각 정점에 연결된 정점들을 배열로 저장하면 연결 리스트의 링크 공간을 절약할 수 있기도 하고 노드가 메모리에 산재(散在)하는 것으로부터도 자유롭다. 이론적으로는 메모리 공간에 분산된 대상을 링크로 관리하면 되지만 이는 메모리 사용 효율이 급격히 떨어진다.

그래프는 대부분 알고리즘 시작부에서 주어지거나 한 번 만들어지면 변하지 않는 정적(Static) 형태이므로 배열 활용이 훨씬 효율적일 수 있다. 인접 여부 체크 시간도 줄일 수 있다. 연결 리스트를 배열로 대체하여 인접 배열 리스트를 사용하는 것도 좋은 방법이다. 정점 j가 정점 i에 인접한지 확인하려면 정점 i의 인접 배열에서 j가 있는지 확인하면 되므로, 정렬된 형태로 배열을 둔다면 이진 탐색을 통해 $\lfloor\log_2{k}\rfloor+1$번 이내의 비교로 $j$의 존재를 알 수 있다. 인접 배열 크기가 100일 때 인접 배열은 7번 이하, 1000일 때 인접 배열은 10번 이하에 해결 가능하다. 또한, 인접 배열 헤더에 인접 정점이 몇 개인지 표시해두면 쉬운 탐색이 가능하다.


![](https://velog.velcdn.com/images/aoi-aoba/post/00823452-9649-4978-8967-62d4a86d5b05/image.png)

물론, 각 정점의 인접 배열을 위해 공간을 따로 할당받지 않고 깔끔히 사용하기 위해 하나의 배열을 할당받아 사용할 수도 있다. 각 인접 배열 크기를 모두 더한 다음, 필요한 전체 배열 크기를 계산한 다음 하나의 배열을 할당받고 각 헤더에는 자신의 인접 배열이 끝나는 자리를 표시하는 것이다. 위 사진의 가장 오른쪽을 보면 각 헤더에 3, 5, 8, 10, 12, 15라는 자리가 표시되어 있고 해당 배열의 해당 인덱스를 통해 구분할 수 있는 것이다.

장점
- 인접 배열을 활용한 경우 정점 간 인접 관계를 쉽게 파악할 수 있다.
- 정렬 상태인 경우 이진 탐색을 통한 비교로 존재를 빠르게 파악할 수 있다.
- 연결 리스트보다는 공간이 덜 들고 검색 시간이 대폭 줄어든다.

단점
- 다룰 그래프가 크기가 매우 큰다면 이진 탐색을 한다고 해도 자주 하기가 만만치 않다.
- 검색을 자주 해야 한다면 부담스러울 수 있다.

### 인접 해시 테이블을 활용한 표현
인접 배열의 검색 효율을 높이기 위해 각각의 인접 배열을 해시 테이블로 대체하는 방법도 존재한다. 각 인접 배열 크기의 2배 정도의 공간을 할당해 적재율을 0.5로 만들면 평균 2번의 비교로 가능하다. 인접 해시 테이블(Adjacency Hash Table)로 다음과 같이 표현할 수 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/cba36ee6-5e54-43bb-b511-6c9f24fe3c2f/image.png)

해시 테이블을 위한 공간을 할당받을 때도 정점별로 따로 할당받을 수도 있고 위와 같이 하나의 배열에 인접 배열 전체의 크기의 2배를 할당받아 나누어 쓸 수도 있다. 여기서는 할당 크기로 나눈 나머지를 사용하는 선형 탐색 방법을 사용한다. 보통 소수 크기 공간을 할당하지만 여기서는 연결된 정점 수의 2배를 사용한다. 정점의 인덱스가 0에서 $n-1$ 범위에서 고루 분포하기 때문에 짝수를 사용해도 무방해 보인다.

다만, 해시 테이블 방식에서는 임의 정점에 인접한 모든 다른 정점에 순차적으로 접근해야 하는 경우에서는 다소 불편이 따른다. 해시 테이블의 빈 공간을 훑어 지나가야 하는 불편함을 감수한다면 순차 접근도 할 만하다.

## Java를 활용하여 각각의 방식을 구현

다음 그래프를 각각의 방식으로 구현한 코드이다.

![](https://velog.velcdn.com/images/aoi-aoba/post/d2427035-31ee-4646-b6ec-bbca3ea5375c/image.png)

### 인접 배열 (Adjacency Matrix) 방식
```Java
int[][] adjMatrix = new int[6][6];

// 연결된 노드를 1로 표시
adjMatrix[0][1] = adjMatrix[1][0] = 1; // A-B
adjMatrix[0][2] = adjMatrix[2][0] = 1; // A-C
adjMatrix[0][3] = adjMatrix[3][0] = 1; // A-D
adjMatrix[0][5] = adjMatrix[5][0] = 1; // A-F
adjMatrix[1][2] = adjMatrix[2][1] = 1; // B-C
adjMatrix[2][4] = adjMatrix[4][2] = 1; // C-E
adjMatrix[3][5] = adjMatrix[5][3] = 1; // D-F
adjMatrix[4][5] = adjMatrix[5][4] = 1; // E-F
```

### 인접 연결 리스트 (Adjacency Linked List) 방식
```Java
List<Integer>[] adjList = new LinkedList[6];
for (int i = 0; i < 6; i++) adjList[i] = new LinkedList<>();

adjList[0].add(1); adjList[0].add(2); adjList[0].add(3); adjList[0].add(5); // A
adjList[1].add(0); adjList[1].add(2); // B
adjList[2].add(0); adjList[2].add(1); adjList[2].add(4); // C
adjList[3].add(0); adjList[3].add(5); // D
adjList[4].add(2); adjList[4].add(5); // E
adjList[5].add(0); adjList[5].add(3); adjList[5].add(4); // F
```

### 인접 배열(리스트) (Adjacency Array of Arrays) 방식
```Java
int[][] adjArray = new int[6][];

adjArray[0] = new int[]{1, 2, 3, 5}; // A
adjArray[1] = new int[]{0, 2};       // B
adjArray[2] = new int[]{0, 1, 4};    // C
adjArray[3] = new int[]{0, 5};       // D
adjArray[4] = new int[]{2, 5};       // E
adjArray[5] = new int[]{0, 3, 4};    // F
```

### 인접 해시 테이블 (Adjacency HashMap) 방식
```Java
Map<Integer, List<Integer>> adjMap = new HashMap<>();

adjMap.put(0, Arrays.asList(1, 2, 3, 5)); // A
adjMap.put(1, Arrays.asList(0, 2));       // B
adjMap.put(2, Arrays.asList(0, 1, 4));    // C
adjMap.put(3, Arrays.asList(0, 5));       // D
adjMap.put(4, Arrays.asList(2, 5));       // E
adjMap.put(5, Arrays.asList(0, 3, 4));    // F
```
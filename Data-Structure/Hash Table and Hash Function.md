# 해시 테이블과 해시 함수
배열에 $n$개의 키를 저장하면 키를 검색, 삽입, 삭제하는 데 모두 평균 $\Theta(n)$ 시간이 걸린다. 자료의 정렬 형태에 따라 다르긴 하지만 어떤 경우든 작업 중 하나 이상은 $\Theta(n)$ 시간이 걸린다. 이 문제를 개선한 것이 검색 트리이다. 일반적인 검색 트리는 성능이 평균 $\Theta(\log n)$ 시간이 들고, 최악의 경우에는 $\Theta(n)$ 시간이 든다. 최악의 경우에도 $\Theta(\log n)$ 시간이 되게 만든 것이 균형 검색 트리(AVL 트리, 레드-블랙 트리, B-트리 등)이다. 그런데, 저장된 자료 양과 상관 없이 평균 상수 시간 작업이 가능하게 할 수는 없을까? 이것이 바로 '해시 테이블'의 등장 배경이다.

## 해시 테이블
검색 트리는 키가 저장될 자리를 이미 트리에 존재하는 키와 비교하여 상대적으로 결정하는데, 해시 테이블은 키가 저장될 자리를 키 자신의 값으로 결정하는 구조이다. 즉, 저장된 자료와 비교해 자리를 찾는 것이 아니라 한 번의 계산으로 자기 자신의 값에 의해 자기 자리를 찾아 결정하는 것이 중요하다. 임의 키를 해시 테이블에 저장하려면 해당 키의 해싯값을 계산해야 한다. 이 값은 해시 함수에 의해 계산된다.

해시 테이블이 총 $m$개의 키를 저장할 수 있다면 테이블 각 자리는 $0$ 부터 $m-1$의 주솟값을 가지고, 임의 킷값을 입력받아 주소 $0, 1, 2, \cdots, m-1$ 중 한 값을 리턴한다. 이 리턴 값이 바로 해당 키를 저장하는 자리인 것이다. 가장 간단한 방법은 킷값이 $x$이면 $m$으로 나눈 나머지를 해싯값으로 삼는 것이다. 즉, 해시 함수를 $h(x) = x \mod m$으로 해결하는 것이다. 저장한 후에 검색할 때도 해당 키의 해싯값을 계산해 그곳을 보면 된다. 이런 방식으로 해시 테이블은 저장할 위치를 단번에 계산한다.

단, 이런 해시 테이블에도 중요한 장애물이 있다. 예를 들어 $m=15$인 상황에 $x = 3$과 $x=48$의 키를 삽입하려고 한다면 같은 해싯값의 자리에 넣어야 하게 되는데, 이를 **충돌(Collision)**&ZeroWidthSpace;이라고 한다. 충돌 처리는 해시 테이블 이론의 핵심이고 충돌 처리에는 여러 가지가 있다.

해시 테이블에 원소가 차 있는 비율은 해시 테이블의 성능에 중요한 영향을 미치고 이 비율을 **적재율(Load Factor)**&ZeroWidthSpace;이라고 한다. 해시 테이블의 크기가 $m$이고 저장된 키의 총 개수가 $n$이면 적재율은 $\frac{n}{m}$이고 보통 이를 $\alpha$라고 표시한다. 적재율이 높을 수록 충돌 확률이 높아져 성능이 나빠진다.

## 해시 테이블의 객체 구조
해시 테이블의 객체 구조를 생각해보자. 필드로는 해시 테이블로 사용하는 `table[]` 배열과 몇 개의 원소가  있는지를 모니터링하는 `numItems`가 있다. 해시 테이블에 접근하려면 메소드 `insert()`, `search()`, `delete()`, `isEmpty()`, `clear()`를 통해야 한다. 크게 두 가지 정도의 해시 테이블 구현을 할 생각인데, 둘 다 같은 모양의 객체를 가진다. 다만 키를 저장하는 배열 `table[]`의 타입이 다르고 운용 방식이 다르다.

- 해시 테이블 객체의 필드
    - `table[]` : 해시 테이블로 사용하는 배열
    - `numItems` : 해시 테이블의 원소 개수
- 해시 테이블 객체의 메소드
    - `search(x)` : 해시 테이블에서 원소 x를 검색
    - `insert(x)` : 해시 테이블에 원소 x를 삽입
    - `delete(x)` : 해시 테이블에서 원소 x를 삭제
    - `isEmpty()` : 해시 테이블의 빈 상태를 확인
    - `clear()` : 해시 테이블을 비움

## 해시 함수
해시 함수는 킷값을 입력으로 받아 해시 테이블 상의 주소를 리턴한다. 해시 함수는 입력 키를 해시 테이블 전체에 고루 분산시켜서 저장할 수 있게 해야 한다. 두 키가 상대적으로 비슷하다고 해서 다른 키들보다 상대적으로 해싯값이 더 비슷하지 않아야 한다. 이 성질을 잘 만족해야 서로 다른 두 키가 한 주소를 놓고 충돌할 확률이 낮아진다. 

### 나누기 방법(Division Method)
앞에서 제시했던 방법과 같이 $h(x) = x \mod m$과 같은 형태를 갖춘 해시 함수이다. $m$은 해시 테이블의 크기이고, 일반적인 나머지 연산을 활용하여 0부터 $m-1$의 주솟값을 해시로 선택하는 것이 자연스럽다. 이때 해시 테이블의 크기 $m$은 2의 멱수(2를 밑으로 하는 제곱수)에 가깝지 않은 소수를 선택하는 것이 좋다.

만약 $m=2^p$와 같이 진행된다면 입력 키의 하위 $p$비트에 의하여 해시가 결정되므로 분산시키기에 그리 이상적이지 않다. 아래의 표를 보면 입력 키의 하위 $p$비트에 의해 해시가 결정되어 가령 문자열을 변환시킬 경우 '김철수'와 '이철수'의 경우 뒤쪽의 두 기호가 다른 키들보다 비슷하여 인접한 자리에 놓일 경향성이 생긴다. 당장 아래의 경우에도 충돌 케이스가 너무 많아진다.

| x  | (binary) | x % 8 (result) |
|----|----------|----------------|
| 13 | 1101     | 101            |
| 29 | 11101    | 101            |
| 61 | 111101   | 101            |

### 곱하기 방법(Multiplication Method)
나누기 방법은 해시 테이블 크기보다 큰 수를 해시 테이블 크기 범위에 들어오게 수축시키는데, 곱하기 방법은 이와 반대이다. 입력 값을 먼저 0과 1 사이의 실수로 대응시켜 해시 테이블 크기 $m$을 곱해 0과 $m-1$ 사이로 팽창시킨다. 이 방법에서는 해시 함수 특성을 결정짓는 $0<A<1$의 실수 $A$를 준비해야 한다. 임의의 키 $x$에 대해 다음과 같은 과정을 거친다.

- $x$에 $A$를 곱한 다음 소수부만 취한다.
- 소수부에서 $m$을 곱하여 그 정수부만 취한다.

$$h(x) = \lfloor m(xA \mod 1)\rfloor$$

다음과 같은 해시 함수가 나타난다. 만약 크기 $m = 65536$인 해시 테이블에서 $A = 0.6180339887$일 때 키 1025390의 해싯값을 구하려면 $xA = 633725.871673093$이고 이 소수부에 65536을 곱하면 $57125.967...$과 같이 나타나므로 정수부만 취해 57125의 주소를 가지게 된다.

곱하기 방법은 나누기 방법과 달리 해시 테이블의 크기 $m$에 자유도가 높기 때문에 컴퓨터의 이진수 환경에 걸맞는 2의 멱수(2를 밑으로 하는 제곱수) 크기로 할당하는 것이 좋다. 나누기 방법에 비해 낭비 요인은 적지만, 상수 $A$에 따라 해싯값 분포에 영향을 받는다. 크누스는 잘 작동하는 A의 값으로서 다음을 제시했다.

$$A = \frac{\sqrt{5}-1}{2} = 0.6180339887...
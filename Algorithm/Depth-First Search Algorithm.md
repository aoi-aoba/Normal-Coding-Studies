# 깊이 우선 탐색 (Depth-First Search, DFS)
## 개요
그래프에서 모든 정점을 방문해야만 하는 경우가 자주 있다. 모든 정점을 방문하는 대표적인 방법 두 가지는 너비 우선 탐색과 깊이 우선 탐색 알고리즘이다. 두 방법은 매우 간단하지만 그래프 알고리즘에서 핵심적인 위치를 차지한다.

너비 우선 탐색의 경우는 루트부터 시작했다면 루트의 자식을 차례로 방문한다. 다음으로 루트 자식의 자식, 즉 루트에서 두 개의 간선을 거쳐서 도달할 수 있는 정점을 방문한다. 그 다음으로 3개의 간선, 4개의 간선, ... 과 같은 과정을 거쳐서 도달할 수 있는 정점을 순을 방문한다.

이와 반대로 깊이 우선 탐색은 루트의 자식 정점을 하나 방문한 다음 아래로 내려갈 수 있는 곳까지 내려간다. 더 이상 내려갈 수 없다면 위로 되돌아오다가 내려갈 곳이 있다면 즉각 내려간다. 아래는 트리를 대상으로 한 너비 우선 탐색과 깊이 우선 탐색의 예시이며, DFS에 기반한 탐색 방법을 백트래킹(Backtracking)이라고 총칭하기도 한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/184f5eae-4373-4dd8-8b06-1bf4cb080420/image.png)


## 무방향 그래프에 대한 BFS의 수행 예시
무방향 그래프에 대하여 DFS를 수행하는 예시를 통해 알고리즘을 차례로 살펴보자. 

![](https://velog.velcdn.com/images/aoi-aoba/post/8474f56c-bb8a-4bf9-9057-87689b2c59ac/image.png)

(a) 시작 정점으로 정해진 정점을 1로 표시하며 방문한다.   
(b) 정점 1에 인접한 정점 중 하나를 방문하여 2로 표시한다.   
(c) 정점 2에 인접하면서 방문하지 않은 정점을 방문하여 3으로 표시한다.   
(d) 정점 3에 인접하면서 방문하지 않은 정점을 방문하여 4로 표시한다.   
(e) 정점 4에 인접하면서 방문하지 않은 정점은 하나이므로 이곳을 방문하고 5로 표시한다. 정점 5에서 인접한 정점 중 방문하지 않은 정점은 없어 왔던 길로 되돌아가면서 4, 3, 2로 되돌아가는 과정 중 4와 3의 정점에 인접한 정점 중 방문하지 않은 정점은 없다.   
(f) 정점 2에 인접한 정점 중 방문하지 않은 정점이 하나 있으므로 이 정점에 방문하여 6으로 표시한다.   
(g) 정점 6에 인접한 정점 중 방문하지 않은 정점 중 하나를 방문해 이 정점을 7로 표시한다.   
(h) 정점 7에 인접한 정점 중 방문하지 않은 정점은 없으므로 6으로 돌아가고, 인접한 정점 중 방문하지 않은 정점이 하나 있으므로 이곳을 방문해 정점을 8로 표시한다. 정점 8에서도 방문하지 않은 정점은 없고, 정점 6으로 돌아간다. 정점 6도, 그 전으로 돌아가 2도, 그 전으로 돌아가 1도 모두 방문하지 않은 인접한 정점이 없으므로 종료된다.

각 정점을 처음 방문할 때 사용하는 간선은 하나이므로 시작점을 제외한 나머지 $n-1$개의 정점 각각에 대해 첫 방문에 사용한 간선을 모으면 $n-1$개가 된다. 그래프에서 이 간선들만 남긴 상태로 두면 아래와 같은 트리가 되는데, 이를 DFS 트리(깊이 우선 트리)라고 한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/fd5a8ea0-15bb-4a45-b415-ebf0128ca58d/image.png)


## DFS 알고리즘의 작동 방식
```
DFS(G, v):
    // G는 그래프 G=(V, E), v는 정점
    v.visited <- YES
    for each x in set v.adj
    // v.adj는 정점 v의 인접 정점 집합
        if (x.visited = NO) DFS(G, x)
```

정점 v에 대해 `DFS(v)`가 호출되면 먼저 정점 `v`를 방문하였다고 표시하고 이와 인접한 정점 중 방문하지 않은 정점에 대해 각각 DFS를 호출한다. 만약 정점 v에 인접한 정점 중 방문하지 않은 정점 x, y, z가 있더라도 그 중 하나에 대해 DFS를 호출하면 일단 깊이 들어갈 수 있는 데까지 들어간다. 이 과정에서 y나 z가 v가 아닌 다른 점과의 인접성에 의해 방문될 가능성도 배제할 수 없다. 그래서 이미 y나 z가 방문 상태가 되어 돌아오니 DFS를 수행할 필요가 없어지는 경우가 매우 빈번한다. 궁극적으로 시작 정점으로부터 방문할 수 있는 모든 정점에 대해 DFS가 한 번씩 호출된다.

DFS도 BFS처럼 모든 정점을 방문하는 것을 목표로 하며, 항상 그래프의 모든 정점을 방문한다는 것을 전제로 하지 않는다. G가 2개 이상으로 끊겨 있다면 한 번의 DFS로는 끝나지 않고 결과적으로 여러 개로 끊겨 있다면 덩어리의 개수만큼 DFS가 필요하다.

수행 시간은 $\Theta(V+E)$이다. 여러 번 수행해야 할 경우까지 고려하여 모두 합한 시간이며, 정점의 수 $|V|$와 간선의 수 $|E|$ 대신 혼동의 염려 없이 표기한 것이다.
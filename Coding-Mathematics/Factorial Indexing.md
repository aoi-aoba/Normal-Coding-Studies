# 팩토리얼 인덱싱 (Factorial Indexing)

## 🖋️ 개요
[1, 2, 3]이라는 집합이 있다. 이를 순열 순서대로 나열해보자. 그러면...

> [1] 123   
> [2] 132   
> [3] 213   
> [4] 231   
> [5] 312   
> [6] 321

다음과 같이 정렬되는 것을 볼 수 있다. 순열을 이런 방식으로 순서에 맞게 정렬하게 된다면, **1-based index**&ZeroWidthSpace;로서 번호를 지정할 수 있게 되는데, 그렇다면 $N$번째 순열을 구하려고 한다면 어떻게 해야 할까?

단순히 생각한다면, 백트래킹이나 `nextPermutation` 등을 구현하여 직접 순열을 다 순서대로 나열한 다음에 해당 순서에 맞는 값을 가져올 수도 있다. 하지만, 당장 그 개수가 기하급수적으로 늘어 $10!$ 정도만 되어도 만드는 데 걸리는 시간이 무시할 수 없는 수준이다.

이때 생각해볼 수 있는 것이, 팩토리얼 인덱싱이다.

## 사전순 순열의 인덱스 접근 원리
사전순 순열의 구조를 보면 규칙이 있다.

- 첫 번째 자리에 올 수 있는 문자는 [1, 2, 3]의 세 가지이다.
- 만약 첫 글자가 1이면, 뒤에 올 수 있는 순열은 $2! = 2$개 (23, 32)
- 첫 글자가 2이면, 뒤에 올 수 있는 순열은 $2! = 2$개 (13, 31)

그렇다면, 우리는 **몇 번째 자리를 어떻게 채우느냐에 따라 인덱스 접근을 조금 더 편리하게 할 수 있다**&ZeroWidthSpace;는 것이다. 다시 말해, 그 자리를 기준으로 **앞에 몇 개의 순열이 올 수 있는지 계산이 가능하다**&ZeroWidthSpace;는 것이다.

예시를 한 가지 들어보자. [a, b, c, d]라는 문자를, 사전순으로 정렬한 $4! = 24$가지 순열 중에서 $k = 17$번째 순열을 구해보자. (0-based index로는 16번 인덱스이다)

### 첫 번째 자리에 대하여
가능한 문자는 `a, b, c, d`의 4가지이다. 이때, 한 가지 문자를 임의대로 선택했을 때 뒤에 순열은 $3! = 6$가지가 올 수 있다. 그렇다면, 우리가 구하려는 16번 인덱스를 나누면 $\lfloor{16 \div 6}\rfloor = 2$이므로, 세 번째 문자(인덱스 2)인 `c`를 선택한다.

- 남은 문자 : `a`, `b`, `d`
- 남은 순열 번호 : `axxx`와 `bxxx`를 제외했으므로, `16 % 6 = 4`

### 두 번째 자리에 대하여
가능한 문자는 `a, b, d`의 3가지이다. 이때 한 가지 문자를 임의대로 선택했을 때 뒤의 순열은 $2! = 2$가지가 올 수 있다. 그렇다면 우리가 구하려는 남은 인덱스 4를 나누면 $4 \div 2 = 2$이므로, 세 번째 문자(인덱스 2)인 `d`를 선택한다.

- 남은 문자 : `a`, `b`
- 남은 순열 번호 : `caxx`와 `cbxx`를 제외했으므로, `4 % 2 = 0`

### 세 번째 자리에 대하여
가능한 문자는 `a, b`의 2가지이다. 이때 한 가지 문자를 임의대로 선택하게 된다면 뒤에는 한 문자가 그대로 오게 된다. 즉 $1! = 1$이고, 우리가 구하려는 남은 인덱스 1을 나누면 $0 \div 1 = 0$이므로, 첫 번째 문자인 `a`를 선택한다.

### 네 번째 자리와 결정
남은 한 문자는 `b`이다. 그러므로, $k = 17$번째 (0-based index로 16번째) 순열은 `cdab`라고 정해질 수 있다.

## 정리
1. 전체 순열을 사전순으로 나열한다고 가정
2. 각 자리마다 고정되는 문자에 대해 (남은 문자 수 -1)! 개씩의 순열이 있음
3. k번째 순열이 어느 문자 범위에 있는지 계산
4. 해당 문자를 선택하고 남은 문자에서 반복
5. 이 과정을 끝까지 반복하면 정확한 순열을 얻을 수 있음

## 코드화 (java)
```java
public static int factorial(int N) {
	int temp = 1;
    for (int i = 1; i <= N; i++)
    	temp *= N;
    return temp;
}

public static String findPermutation(char[] target, int num) {
	StringBuilder sb = new StringBuilder();
    List<Character> available = new ArrayList<>();
    for (char ch : target) available.add(c)
    
    for (int i = target.length; i > 0; i--) {
    	int fact = factorial(i - 1);
        int idx = num / fact;
        sb.append(available.get(idx));
        available.remove(idx);
        num %= fact;
    }
}
```

위쪽의 과정을 그대로 코드로 만들면 된다.

- `factorial` 메소드는 말 그대로 $N!$의 값을 반환해준다.
- `findPermutation` 메소드에는 parameter로서 `target`이라는 문자열의 배열(`String.toCharArray()`)과 몇 번째 인덱스 값을 찾을지에 대한 `num`(0-based index)를 받는다.
- 각 인덱스의 문자를 이어붙이는 과정을 위에서 한 대로, 남은 인덱스를 팩토리얼로 나눈 값으로 찾는다. 소숫점을 여기서는 버리는 방식 (integer 형 변환)을 차용했는데, **0-based index**&ZeroWidthSpace;이기 때문에 가능한 일이다.
- 값을 받아서 이어붙이고, 그 문자는 사용했으므로 지운다. 그리고 남은 인덱스를 계산하면 된다.

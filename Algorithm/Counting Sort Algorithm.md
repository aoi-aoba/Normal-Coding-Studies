# 계수 정렬(Counting Sort) 알고리즘

## 계수 정렬의 아이디어
정렬하고자 하는 원소들의 값이 $-O(n) \sim O(n)$의 범위 내에 있는 정수인 경우에 사용할 수 있는 
정렬이다. 예를 들어, 배열 `A[0...n-1]`에 있는 원소들의 값이 $0 \sim 2n, -n \sim 3n$ 등 범위에 있는
정수인 경우다. 원소들의 값이 모두 $0 \sim k$ 사이의 정수라고 하자. 계수 정렬은 먼저 배열의 원소를
전부 훑어서 1부터 $k$까지의 자연수가 각각 몇 번 나타나는지를 센다. 이 정보가 있다면 배열 `A[]`의
각 원소가 몇 번째 자리에 놓이면 되는지를 계산할 수 있다.

## 계수 정렬의 알고리즘
```
countingSort(A[], n):
    for i <- 0 to k             // (1)
        C[i] <- 0
    for j <- 0 to n-1         // (2)
        C[A[j]]++
        // 이 시점에서의 C[i]는 값이 i인 원소의 총 수
    for i <- 1 to k             // (3)
        C[i] <- C[i] + C[i-1] // 누적합 계산
        // 이 시점에서의 C[i]는 i보다 작거나 같은 원소의 총 개수
    for j <- n-1 downto 0   // (4)
        B[C[A[j]]-1] <- A[j]
        C[A[j]]--
    return B
```
알고리즘에서 `A[0...n-1]`을 저장한 결과가 `B[0...n-1]`에 저장된다.   
먼저, (2)의 for 루프에서 배열 `C[0...k]`에 정수 0부터 k 각각이 배열 `A`에서 몇 번 나타나는지를 센다.
즉, `C[i]`는 값이 `i`인 원소의 총 개수를 갖고 있게 된다. 그런 다음, 이를 이용해 (3)의 for 루프에서 
`C[i]`가 값이 `i`보다 작거나 같은 원소의 총 개수를 갖고 있도록 바꾼다. 즉 **누적합을 보유하게** 한다.
마지막으로 (4)의 for 루프에서 이 정보를 이용해 배열 `A`의 각 원소가 배열 `B`의 몇 번째 자리에 들어갈
지를 계산하여 저장한다. `B[0...n-1]`은 정렬 결과를 가지게 된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/5344bc03-bb9f-44fb-bbb4-ba76b51c0af8/image.png)

계수 정렬의 저장 위치를 나타낸 것이다. `A[i] = y`이다. `C[y] = q`라는 값을 가지고 있다. 이들은 각각 처음에
주어진 배열에서 `i`번째에 `y`라는 값이 있고, 그 해당 `y`라는 값이 배열 내에서 `q`번 나타났다는 것이다.
그러면 이 값을 보게 되면 `q`라는 값은 결과적으로 **이전까지의 원소들에 대해 빈도 누적합이 담겨져 있다.**
값이 0부터 저장되기 시작하여 `q`개에 저장되어있다는 것이기 때문에 결국 `B[q-1]`이 해당 `y`라는 값이 자리하는
마지막 위치라는 것이다. 그러면 `A[i]`(=`y`)는 (4)에서 `B[q-1]`에 저장되고, `C[y]`값을 1 감소시킨다.
다음에 어떤 `A[j]=y`이면 이 `y`는 방금 `y`를 저장한 바로 앞자리에 저장해야 하기 때문이다.

## 계수 정렬의 수행시간 판단
계수 정렬의 수행 시간은 당연히 $\Theta(n)$이다. 총 4개의 for 루프가 시간을 결정하는데, (1)과 (3)의
for 루프는 각각 $\Theta(k)$이고, (2)와 (4)의 for 루프는 각각 $\Theta(n)$ 시간이 소요된다. $k=O(n)$이므로
총 시간은 $\Theta(n)$이다. 만약 $k$가 $O(n)$을 초과하면 시간은 $O(k)$가 되는데 그러면 계수 정렬의
메리트가 없다. 정렬할 원소가 꼭 양수일 필요도 없다. 원소들이 모두 -k에서 k 사이의 정수이고 k가 O(n)이기만
하면 간단히 조정해서 선형 시간에 정렬할 수 있다.

## 구현
JAVA를 활용해 구현한 코드는
Normal-Coding-Studies/Data-Structure-With-JAVA/Data-Structure/src/Data-Structure/sort 
내에 있다.
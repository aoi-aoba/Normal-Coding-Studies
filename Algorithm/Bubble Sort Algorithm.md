# 버블 정렬(Bubble Sort) 알고리즘
선택 정렬과 유사한 아이디어에 기반하지만, 제일 큰 원소를 옮기는 방법이 다른 알고리즘이다.

## 버블 정렬의 아이디어
아래의 그림을 보면서 선택 정렬의 아이디어를 알아보자.

![](https://velog.velcdn.com/images/aoi-aoba/post/17edc81f-617c-4e37-84c3-69487147f144/image.png)

먼저 임의의 배열 `A[0...n]`을 받아오고, 왼쪽부터 배열을 돌기 시작한다. 왼쪽부터 배열을 돌면서 바로
한 칸 오른쪽에 있는 수와 크기를 비교하고, **순서가 맞지 않으면 swap한다.** 이 점이 선택 정렬과
가장 차이가 있는 부분이다. 그래서 버블 정렬은 **선택 정렬보다 느리다.** 그래서 루프를 돌면서 
그냥 계속 루프만 도는 것이 아니라, 원소 교환이 일어나는지 아닌지에 대한 루프를 체크하게 하면
대체로 더 빨라질 수는 있다. 아래에서 따로 확인하자.

## 가장 무난한 버블 정렬의 알고리즘
```
bubbleSort(A[], n):
    for last <- n-1 downto 1
        for i <- 0 to last-1
            if (A[i] > A[i+1])
                A[i] <-> A[i+1] // swap
```

## 가장 일반적인 버블 정렬의 수행시간
버블 정렬의 수행 시간은 두 수를 비교하는 작업이 시간을 좌우하게 된다. 버블 정렬은 모든 경우에 대해
$\Theta(n^2)$의 형태로 나타난다.
- 맨 앞의 for 루프에서 `n-1` 번 순환한다.
- 안쪽의 for 루프에서는 부분 배열의 크기에 비례하는 시간을 가진다.
- 부분 배열은 `n`에서 시작하여 `2`까지 감소한다. 총 $\frac{n(n-1)}{2}$번이다.

여기에서 최고차항이 2차인 함수가 나타남에 따라 시간 복잡도가 $\Theta(n^2)$의 형태로 나타난다.

## 버블 정렬 알고리즘을 개선하는 방법 - 이미 정렬된 경우를 감지하여 조기에 종료
버블 정렬이 오래 걸리는 원인 중 하나는, 최악의 경우의 $\Theta(n^2)$ 자체가 **정렬이 되어 있어도
모든 원소를 돌면서 체크**&ZeroWidthSpace;하기 때문이다. 그러면 우리는 정렬이 되어 있는 상태가 
중간에 발견된다면, 이 경우 조기에 종료해버릴 때 수행 시간을 단축할 수 있다.

```
enhancedBubbleSort1(A[], n):
    for last <- n-1 downto 1
    swapped <- false
        for i <- 0 to last-1
            if (A[i] > A[i+1])
                A[i] <-> A[i+1] // swap
                swapped <- true
        if (!swapped) break
```
`swapped`라는 swap 여부를 확인하는 `boolean` 변수를 활용하여서, swap이 일어났다면 `true`를
할당하고 아니면 `false`를 할당하자. 그리고 한 번 배열을 다 돌았을 때 만약 이 변수가 `false`라면
swap이 이미 일어나지 않은 상태에서 배열을 돈 것이므로 바로 나가버리면 된다.

### 위 로직에서의 버블 정렬 개선
버블 정렬이 항상 최악의 경우 $\Theta(n^2)$로 상정되는 반면에, 위 로직의 최선의 경우 $\Theta(n)$으로 개선할 수 있다.
이 차이가 가장 큰 경우는 **이미 정렬된 배열이 주어진 경우**&ZeroWidthSpace;인데, 이전에는 배열 자체가 정렬이 되어
있든 아니든 간에 그냥 쭉 돌리면서 모든 경우를 체크해야 하지만 위 로직에서는 이미 정렬되어 한 번 쭉 가면서 비교한 게 없으면
바로 중단해서 비교를 그만두기 때문이다. $n$이 클수록 이 차이는 극명하게 나타날 것이다.

## 구현
JAVA를 활용해 구현한 코드는 Normal-Coding-Studies/Data-Structure-With-JAVA/Data-Structure/src/Data-Structure/sort 내에 있다.
이 코드에서는 enhancedBubbleSort만을 구현한다.
# 셸 정렬(Shell Sort) 알고리즘

## 셸 정렬의 아이디어
셸 정렬은 삽입 정렬의 특성을 활용한 정렬이다. 이미 정렬되어 있거나 거의 정렬되어 있으면 $\Theta(n)$의 시간 복잡도
선에서 해결이 가능한 삽입 정렬의 특성을 이용해, 삽입 정렬로 끝내기 전에 각 원소가 있을 자리에서 멀리 떨어져 있을 가능성을
현저히 줄이는 과정을 거쳐 삽입 정렬의 효율성을 높인다.

우선 배열 전체를 $h_0$ 간격의 부분 배열로 나눈다. 원소를 $h_0$의 간격으로 뽑아서 그룹을 지은 다음, 각각의 그룹을
삽입 정렬한다. 원소의 총 수가 $h_0$개보다 작지 않으면 부분 배열은 총 $h_0$개가 된다. 그 다음에 더 좁아진 간격인
$h_1$으로 만들어지는 $h_1$개의 부분 배열 각각을 삽입 정렬하고, 이처럼 간격을 $h_2, h_3, \cdots$ 과 같이 좁혀나가며
삽입 정렬을 반복하다가 마지막으로 간격 1이 되면 전체가 하나의 그룹이 됨에 따라 마지막 삽입 정렬을 하고 마친다.

간격의 수열 $h_n$을 **갭 수열(Gap sequence)**&ZeroWidthSpace;라고 한다.  갭 수열은 잡는 방법이 매우 다양한데, 
그 예시로 $\frac{n}{2}$보다 작은 어딘가에서 $2^k-1$을 만족하는 수를 차례로 잡는 것이다. 이 경우 $31, 15, 7, 3, 1$과 
같이 된다. 다른 예로서는, $h_0=\frac{n}{7}$로 잡고, $h_i=h_{i-1}/5-1$로 변화시키면서 5보다 $h_i$보다 큰 동안 간격
$h_i$의 삽입 정렬을 수행한 다음, 마지막으로 전체 배열에 대하여 삽입 정렬을 한다. 성능은 **마지막 삽입 정렬의 시간을
단축시킨 정도에 비해 앞의 준비 단계에서 소모한 시간이 얼마나 더 작은가**&ZeroWidthSpace;에 달려 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/1f2146f1-2ed6-4b97-9ea4-c294bfb50d1d/image.png)

위 그림은 셀 정렬을 나타낸 것이다. 빨간색 음영으로 나타낸 부분이 부분 배열에 해당한다. 초록색 음영으로 나타낸 부분은
해당 부분 배열을 정렬한 것이고, 부분 배열의 정렬이 완료되면 파란색 음영으로 지정하였다. 물론 이와 같이 항상 순차적으로
부분 배열을 처리할 필요는 없으나 결과적으로 원리와 결과값은 동일하기 때문에 따로 이를 지정하지는 않았다. 통상적인 삽입 
정렬로 이를 처음부터 해결하려고 한다면 기본적으로 각 원소의 움직임이 굉장히 지나치다. 그렇기 때문에 셸 정렬 알고리즘이 
이점을 가질 수 있는 것이다.

## 셸 정렬의 주요 알고리즘
```
shellSort(A[]):
    for h <- h0, h1, h2, ..., 1 // Gap Sequence
        for k <- 0 to h-1
            stepInsertionSort(A, k, h)

stepInsertionSort(A[], k, h): // 부분배열 A[k, k+h, k+2h, ...]
    for (i <- k + h; i <= n-1; i <- i+h)
        insertionItem <- A[i]
        for (j <- i - h; 0 <= j and insertionItem < A[j]; j <- j - h)
            A[j+h] <- A[j]
        A[j+h] <- InsertionItem
```
미리 설정된 갭 수열의 종류만큼 순환하는 for 문에 대하여, 변형된 삽입 정렬 알고리즘(`stepInsertionSort`)을 실행한다.
이 삽입 정렬은 `A[k, k+h, k+2h, ...]`을 대상으로 하기 때문이다. `h` 간격으로 분포하는 모든 원소를 대상으로 하기 때문에
기본적인 삽입 정렬과 같은 로직으로 움직이긴 하지만 왼쪽으로 하나하나 살피는 것이 아나니라 왼쪽으로 `h`씩 점프하며 살피는
것이 다르다. 마지막에는 `stepInsertionSort(A, 0, 1)`이 호출되고 이는 일반 삽입 정렬과 동일하다.

## 셸 정렬에서 주로 사용하는 갭 수열
### A003462 Knuth Sequence
$$h_n = \frac{3^k-1}{2} (h_n ≤ \lceil N/3 \rceil)$$
전체 정렬 원소 개수 $N$에 대하여 $\frac{N}{3}$을 넘지 않는 범위에서 해당 점화식을 적용하여 수열을 구하면 된다.
> 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484, 7174453, 21523360, 64570081, 193710244

### A108870 Tokuda Sequence
$$\left\lceil \frac{1}{5} \left( 9 \cdot \left( \frac{9}{4} \right)^{k-1} - 4 \right) \right\rceil
$$
이 식은 아래의 등비수열 합 형태로도 제시된다.
$$\left\lceil \frac{ \left( \frac{9}{4} \right)^k - 1 }{ \frac{9}{4} - 1 } \right\rceil$$
> 1, 4, 9, 20, 46, 103, 233, 525, 1182, 2660, 5985, 13463, 30240, 67907, 152851, 344826, 778103, 1758946, 3972615, 8978386, 20288288, 45848726, 103636191, 234991147, 532230530

### A102549 Ciura Sequence
Ciura 수열의 경우, 위의 Knuth 수열이나 Tokuda 수열과는 달리, Ciura가 실제 정렬 성능을 실험적으로 측정해서 도출한 것이기
때문에 일반적으로는 1750 이하에서만 사용해도 충분하나, 수열을 더 확장하고 싶다면 그의 논문에서 사용한 방법 대로 1.3~2.25 정도의
배수로 점차 증가시키며 실험적으로 확장했는데, 가장 일반적으로 사용되는 확장 방식은 이전 값의 2.25배를 활용하는 것이다. 물론 고정값은
> 1, 4, 10, 23, 57, 132, 301, 701, 1750

정도에서 정리가 가능하다.

> 1, 4, 10, 23, 57, 132, 301, 701, 1750, 3937, 8858, 19930, 44842, 100894, 227011, 510774, 1149241, 2585791, 5818029, 13090565, 29453771, 66270984, 149110714, 335498106, 754870738


## 셸 정렬의 수행시간 판단
셸 정렬은 `shellSort()` for 루프 2개와 `stepInsertionSort()`의 for 루프 2개가 수행 시간을 좌우한다. 또, 3개의 for 루프가
궁극적으로 마지막 for 루프로 연결되고, 마지막 for 루프를 한 번 순환하는 데 상수 시간이 드므로 for 루프에서의 조건 비교
횟수가 시간을 좌우하기 때문에 마지막 for 루프의 총 순환 횟수가 전체 수행 시간을 결정한다.

`stepInsertionSort()`는 총 `h`번 시행되는데, 이들을 합한 시간은 $\Omega(n)$으로 나타난다. 만일 갭 수열 $h_i$가 
$\Omega(n)$ 크기에서 시작하여 $h_i = h_{i-1}/k-1$와 같은 방식으로 상수로 나누면서 줄어들 경우 이런 $h_i$가 
$\Theta(\log{n})$개 있으므로 (=첫 번째 for 루프가 총 $\Theta(\log{n})$회 순환하므로) 전체는 $\Omega(n\log{n})$이 
된다. 셸 정렬의 수행 시간은 구현 방법이 다양해 분석하기가 쉽지 않아 갭 수열에 따라 편차가 있으나 가장 좋은 상한은 지금까지
$O(n^{1.25})$로 알려져 있다.

셸 정렬은 삽입 정렬의 개선 알고리즘이나 개선 정도는 획기적인 편이다. 1천 개짜리 배열은 1.3배 정도밖에 빠르지 않으나, 10만
개의 경우 100배, 1000만 개의 경우 약 5만 5천 배 정도나 빨라진다. 그렇지만 퀵 정렬에 비해서는 다소 느린 편이다. 1만 개에서
1천만 개 사이의 배열에서는 1.3~1.8배 정도 느리고, 1억 개짜리 배열에 대해서는 2.3배 정도 느리다. 원시 삽입 정렬을 간단히
전처리한 것을 감안하면 놀라운 수준이라 볼 수 있겠다.

## 구현
JAVA를 활용해 구현한 코드는 Normal-Coding-Studies/Data-Structure-With-JAVA/Data-Structure/src/Data-Structure/sort 내에 있다.
주로 사용되는 갭 수열 세 가지를 제시해두었다.